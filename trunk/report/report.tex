\documentclass[11pt]{report} 
\usepackage{epsf}
\usepackage{graphicx}
\usepackage{index}
\usepackage{varioref}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{theorem} % for examples
\usepackage{alltt}
\usepackage{epic,eepic}
\usepackage{boxedminipage}
\usepackage{fancybox}
\usepackage[square]{natbib}
\usepackage{ps4pdf}
\usepackage{picins} % pictures next to paragraphs, Ondrej's part
\usepackage{avm}
\usepackage{epsfig}
\PSforPDF{
\usepackage{dtree} % a dependency tree
\usepackage{pstricks}
\usepackage{pst-node}
\usepackage{pst-plot}
}
\usepackage{subfig}
\oddsidemargin 0mm
\evensidemargin 5mm
\topmargin 0mm
\textheight 220mm
\textwidth 160mm

\makeindex
\theoremstyle{plain}

\begin{document}
\title{\vspace{-25mm}\LARGE {\bf Final Report}\\[2mm]
of the\\[2mm]
2006 Language Engineering Workshop\\[15mm]
{\huge \bf Open Source Toolkit\\[2mm]
\bf for Statistical Machine Translation:\\[5mm]
Factored Translation Models\\[2mm]
and Confusion Network Decoding}\\[10mm]
{\tt \Large http://www.clsp.jhu.edu/ws2006/groups/ossmt/}\\[2mm]
{\tt \Large http://www.statmt.org/moses/}\\[15mm]
Johns Hopkins University\\[2mm]
Center for Speech and Language Processing}
\author{\large Philipp Koehn,
Marcello Federico,
Wade Shen,
Nicola Bertoldi,\\
\large Ond\v{r}ej Bojar,
Chris Callison-Burch,
Brooke Cowan,\\
\large Chris Dyer,
Hieu Hoang,
Richard Zens,\\
\large Alexandra Constantin,
Christine Corbett Moran,
Evan Herbst}

\maketitle
 
\section*{Abstract}
{\large The 2006 Language Engineering Workshop {\em Open Source Toolkit for Statistical Machine Translation} had the objective to advance the current state of the art in statistical machine translation in respect to dealing with richer input and richer annotation of the textual data. The work breaks down into three goals: factored translation models, confusion network decoding, and the development of an open source toolkit that incorporates this advancements.

This report describes the scientific goals, the novel methods, and experimental results of the workshop. It also documents details of the implementation of the open source toolkit.
}

\newpage
\section*{Acknowledgments}

\newpage
\section*{Team Members}

\begin{itemize}
\item Philipp Koehn, Team Leader, University of Edinburgh
\item Marcello Federico, Senior Researcher, ITC-IRST
\item Wade Shen, Senior Researcher, Lincoln Labs
\item Nicola Bertoldi, Senior Researcher, ITC-IRST
\item Chris Callison-Burch, Graduate Student, University of Edinburgh
\item Richard Zens, Graduate Student, RWTH Aachen University
\item Hieu Hoang, Graduate Student, University of Edinburgh
\item Brooke Cowan, Graduate Student, MIT
\item Ond\v{r}ej Bojar, Graduate Student, Charles University
\item Chris Dyer, Graduate Student, University of Maryland
\item Alexandra Constantin, Undergraduate Student, Williams College
\item Evan Herbst, Undergraduate Student, Cornell
\item Christine Corbett Moran, Undergraduate Student, MIT
\end{itemize}

\tableofcontents

\chapter{Introduction}
Statistical machine translation has emerged as the dominant paradigm in machine translation research, raising hopes again to come closer to the dream of building machines that translate foreign languages --- a dream that is as old as artificial intelligence research itself.

While statistical machine translation is built on the insight that many translation choices --- be it be how to translate an ambiguous input word or when to reorder the words of a sentences --- have to balanced against each other. The balancing of these choices is done using probabilistic estimates collected from translated text, or other useful scoring functions.

The multitude of choices is increased, if machine translation becomes part of a larger application, for instance part of a speech translation system. In this case, the input to the machine translation system may be ambiguous in itself, and we would like to add the capability to deal with such ambiguous input. 

While statistical machine translation research has gained much from building on the insight of using probabilistic choices to make the many decisions in translations, it has had problems with another insight into the translation process: much of the transformation is best explained with morphological, syntactical, semantic, or otherwise obtained knowledge. Integrating such knowledge into statistical machine translation will allow us to build richer models.

We address these two challenges with approaches called {\bf confusion network decoding} amd {\bf factored translation models}. We also address another problem of doing research in this field. The methods and systems we develop become increasingly complex. Catching up with the state of the art has become a major part of the work done by research groups. To reduce this tremendous duplication of efforts, we make our work available in form of an {\bf open source toolkit}.

To this end, we merged the efforts of a number of research labs (University of Edinburgh, ITC-irst, MIT, University of Maryland, RWTH Aachen) in a common set of tools, including the core of a machine translation system: the decoder. This report documents this effort that we will persue beyond the efforts at the summer workshop.

\section{Factored Translation Models}
{\sc \begin{itemize}
\item outperform traditional phrase-based models
\item framework for a wide range of models
\item integrated approach to morphology and syntax
\end{itemize}}

Our approach to factored translation models is described in detail in Chapter~\ref{chap:factored-models}.

\section{Confusion Network Decoding}
{\sc \begin{itemize}
\item exploit ambiguous input and outperform 1-best
\item enable integrated approach to speech translation
\end{itemize}}

Our approach to confusion network decoding is described in detail in Chapter~\ref{chap:confusion-networks}.

\section{Open Source Toolkit}
{\sc \begin{itemize}
\item advances state-of-the-art of statistical machine translation models
\item best performance of European Parliament task
\item competitive on IWSLT and TC-Star
\end{itemize}}

The implementation and usage of the toolkit is described in more detail in Chapter~\ref{toolkit}.

\chapter{Factored Translation Models}\label{chap:factored-models}
The current state-of-the-art approach to statistical machine translation, so-called phrase-based models, are limited to the mapping of small text chunks without any explicit use of linguistic information, be it morphological, syntactic, or semantic. Such additional information has been shown to be valuable when it is integrated into pre-processing or post-processing steps. 

For instance, improvements in translation quality have been achieved by handling Arabic morphology through stemming or splitting off of affixes that typically translate into individual words in English. Another example is our earlier work on methods to reorder German input, so it is more similar to English output sentence order, which makes it more amendable to the phrase-based approach \cite{Collins2005}.

However, a tighter integration of linguistic information into the translation model is desirable for two reasons:
\begin{itemize}
\item Translation models that operate on more general representations, such as lemmas instead of surface forms of words, can draw on richer statistics and overcome the data sparseness problems caused by limited training data.
\item Many aspects of translation can be best explained on a morphological, syntactic, or semantic level. Having such information available to the translation model allows the direct modeling of these aspects. For instance: reordering at the sentence level is mostly driven by general syntactic principles, local agreement constraints show up in morphology, etc.
\end{itemize}

Therefore, we developed a framework for statistical translation models that tightly integrates additional information. Our framework is an extension of the phrase-based model \cite{OchThesis}. It adds additional annotation at the word level. A word in our framework is not anymore only a token, but a vector of factors that represent different levels of annotation.

\begin{center}
\includegraphics[scale=0.75]{factors.pdf}
\end{center}

Typical factors that we experimented with at this point include surface form, lemma, part-of-speech tag, morphological features such as gender, count and case, automatic word classes, true case forms of words, shallow syntactic tags, as well as dedicated factors to ensure agreement between syntactically related items. 

\section{Motivation}
One example to illustrate the short-comings of the traditional surface word approach in statistical machine translation is the poor handling of morphology. Each word form is treated as a token in itself. This means that the translation model treats, say, the word {\em house} completely independent of the word {\em houses}. Any instance of {\em house} in the training data does not add any knowledge to the translation of {\em houses}. 

In the extreme case, while the translation of {\em house} may be known to the model, the word {\em houses} may be unknown and the system will not be able to translate it. While this problem does not show up as strongly in English --- due to the very limited morphological production in English --- it does constitute a significant problem for morphologically rich languages such as Arabic, German, Czech, etc.

Thus, it may be preferably to model translation between morphologically rich languages on the level of lemmas, and thus pooling the evidence for different word forms that derive from a common lemma. In such a model, we would want to translate lemma and morphological information separately, and combine this information on the target side to generate the ultimate output surface words.

Such a model, which makes more efficient use of the translation lexicon, can be defined as a factored translation model. See below for an illustration of this model in our framework.

\begin{center}
\includegraphics[scale=0.75]{factored-morphgen-symmetric.pdf}
\end{center}

Note that while we illustrate the use of factored translation models on such a linguistically motivated example, our framework also applies to models that incorporate statistically defined word classes.

\section{Decomposition of Factored Translation}\label{sec:factored-decomposition}
The translation of the factored representation of source words into the factored representation of target words is broken up into a sequence of {\bf mapping steps} that either {\bf translate} input factors into output factors, or {\bf generate} additional target factors from existing target factors.

Recall the previous  of a factored model that translates using morphological analysis and generation. This model breaks up the translation process into the following steps:
\begin{itemize}
\item Translating of input lemmas into target lemmas
\item Translating of morphological and syntactic factors
\item Generating of surface forms given the lemma and linguistic factors
\end{itemize}

Factored translation models build on the phrase-based approach that breaks up the translation of a sentence in the translation of small text chunks (so-called phrases). This model implicitly defines a segmentation of the input and output sentences into such phrases. See an example below:

\begin{center}
\includegraphics[scale=0.75]{phrase-model-houses.pdf}
\end{center}

Our current implementation of factored translation models follows strictly the phrase-based approach, with the additional decomposition of phrase translation into a sequence of mapping steps. Since all mapping steps operate on the same phrase segmentation of the input and output sentence into phrase pairs, we call these {\bf synchronous factored models}. 

Let us now take a closer look at one example, the translation of the one-word phrase {\em h{\"a}user} into English. The representation of {\em h{\"a}user} in German is: surface-form {\em h{\"a}user}, lemma {\em haus}, part-of-speech {\em NN}, count {\em plural}, case {\em nominative}, gender {\em neutral}. 

Given the three mapping steps in our morphological analysis and generation model may provide the following applicable mappings:
\begin{itemize}
\item {\bf Translation:} Mapping lemmas
\begin{itemize}
\item {\em haus $\rightarrow$ house, home, building, shell}
\end{itemize}
\item {\bf Translation:} Mapping morphology
\begin{itemize}
\item {\em NN$|$plural-nominative-neutral $\rightarrow$ NN$|$plural, NN$|$singular} 
\end{itemize}
\item {\bf Generation:} Generating surface forms
\begin{itemize}
\item {\em house$|$NN$|$plural $\rightarrow$ houses} 
\item {\em house$|$NN$|$singular $\rightarrow$ house} 
\item {\em home$|$NN$|$plural $\rightarrow$ homes} 
\item {\em ...}
\end{itemize}
\end{itemize}

The German {\em haus$|$NN$|$plural$|$nominative$|$neutral} is expanded as follows:
\begin{itemize}
\item {\bf Translation:} Mapping lemmas\\
{\em \{ ?$|$house$|$?$|$?,$\;\;$ ?$|$home$|$?$|$?,$\;\;$ ?$|$building$|$?$|$?,$\;\;$ ?$|$shell$|$?$|$? \}}
\item {\bf Translation:} Mapping morphology\\
{\em \{ ?$|$house$|$NN$|$plural,$\;\;$ ?$|$home$|$NN$|$plural,$\;\;$ ?$|$building$|$NN$|$plural,$\;\;$ ?$|$shell$|$NN$|$plural,$\;\;$ ?$|$house$|$NN$|$singular,$\;\;$ ...~\}}
\item {\bf Generation:} Generating surface forms\\
{\em \{ houses$|$house$|$NN$|$plural,$\;\;$ homes$|$home$|$NN$|$plural,$\;\;$ buildings$|$building$|$NN$|$plural,$\;\;$ shells$|$shell$|$NN$|$plural,$\;\;$ house$|$house$|$NN$|$singular,$\;\;$ ...~\}}
\end{itemize}

\section{Statistical Modeling}
Factored translation models follow closely the statistical modeling methods used in phrase-based models. Each of the mapping steps is modeled by a feature function. This function is learned from the training data, resulting in translation tables and generation tables.

Phrase-based statistical translation models are acquired from word-aligned parallel corpora by extracting all phrase-pairs that are consistent with the word alignment. Given the set of extracted word pairs with counts, various scoring functions are estimated, such as conditional phrase translation probabilities based on relative frequency estimation.

Factored models are also acquired from word-aligned parallel corpora. The tables for translation steps are extracted in the same way as phrase translation tables. The tables for generation steps are estimated on the target side only (the word alignment plays no role here, and in fact additional monolingual data may be used). Multiple scoring functions may be used for generation and translation steps, we used in our experiments
\begin{itemize}
\item five scores for translation steps: conditional phrase translation probabilities in both direction (foreign to English and vice versa), lexical translation probabilities (foreign to English and vice versa), and phrase count;
\item two scores for generation steps: conditional generation probabilities in both directions (new target factors given existing target factors and vice versa).
\end{itemize}

As in phrase-based models, the different components of the model are combined in a log-linear model. In addition to traditional components --- language model, reordering model, word and phrase count, etc. --- each mapping steps forms a component with five (translation) or two (generation) features. The feature weights in the log-linear model are determined using a minimum error rate training method (cite Och, simplex).

\section{Efficient Decoding}
Compared to phrase-based models, the decomposition of the phrase translation into several mapping steps creates additional computational complexity. Instead of a simple table lookup to obtain the possible translation for an input phrase, now a sequence of such tables have to be consulted and their content combined.

Since all translation steps operate on the same segmentation, the {\bf expansion} of these mapping steps can be efficiently pre-computed prior to the heuristic beam search, and stored as translation options (recall the example in Section~\ref{sec:factored-decomposition}, where we carried out the expansion for one input phrase). This means that the fundamental search algorithm does not change. Only the scoring of hypothesis becomes slightly more complex.

However, we need to be careful about the combinatorial explosion of the number of translation options given a sequence of mapping steps. If one or many mapping steps result in a vast increase of (intermediate) expansions, this may be become unmanageable. We currently address this problem by early pruning of expansions, and limiting the number of translation options per input phrase to a maximum number, by default 50.

\section{Future Research}
%{\sc add ideas from Wade Shen, Hieu Hoang, Chris Dyer}
\subsection{Smarter search for multi-factored models}
Although factored translation models can be successfully used to
improve translation quality (in terms of {\sc bleu} score, as well
as other metrics, such as the rate of agreement errors in the output
text), initial experiments suggest two changes to the translation
model and decoding strategy that will enable more sophisticated
models (that take advantage of linguistically motivated
decomposition and generation processes, for example) and enable the
models to be applied in situations where the target language is
morphologically less complex (such as English).

\subsubsection{Shorter secondary spans}

One significant limiting factor in the performance of multi-factored
translation models is the due to the present requirement that
successive translation steps all translate identical source and
target spans.  If a compatible translation is not found for a
secondary translation step (either because hypotheses with
compatible factors were discarded earlier or because there is no
possible translation in the phrase table for the secondary
translation step), the hypothesis is abandoned. This has
considerable benefit from a computational perspective since it
constrains the search space for potential targets when translating
secondary factors.  However, it causes a number of significant
problems:
\begin{enumerate}
  \item In models where a secondary factor is both generated from another
target factor and translated from a source factor, any pruning
before both steps have completed runs the risk of producing not just
degraded output, but failing to find any adequate translation.
  \item Because a compatible translation must be found in secondary steps
for a translation hypothesis to survive, it is difficult to filter
secondary translation tables.  This results in very large tables
which are inefficient to load and have considerable memory overhead.
  \item When secondary translation steps fail and hypotheses are
abandoned, the model is forced to rely on shorter translation units
for the primary translation step. This is in direct conflict to the
potential benefits that can be gained by richer statistics.
\end{enumerate}

There are several possible ways that the exact-span match
requirement might be addressed. One solution that is computationally
tractable is to back off to shorter spans only in the event of a
failure to find any possible translation candidates during
subsequent translation steps.  The problem that arises is how the
spans established should be translated once multiple translation
units can be used.  Reordering within phrases is certainly quite
common.  These can be further constrained to either match alignments
that are suggested by the initial span.

\subsubsection{Translation-constrained generation with FSTs}

Currently when translation hypotheses are enumerated for a
particular span of the source sentence (the first step in the
translation process), each step in the mapping (whether translation
or generation) occurs serially and pruning occurs after each step.
Furthermore, multiple generation and translation steps frequently
target the same factor in a particular model (for example, a
target-side lemma may generate target-side part of speech
candidates, and source-side part of speech information may also be
translated into target-side part of speech sequences).  When the
same factor is generated in multiple mapping steps, they must all
converge or the hypothesis is abandoned.

The serial approach to computing translation options has two primary
drawbacks:

\begin{enumerate}
  \item Since a translation hypotheses is abandoned unless all steps in the
mapping succeed fully, it is often the case that many hypotheses
that survive pruning after one step are abandoned at a later step,
and that many that were pruned would have ended up being a
reasonable hypothesis.
  \item There are an exponential number of generation candidates available
for a given target span (where the exponent is the length of the
span and the base is the average number of targets from a given
source in the generation table).
\end{enumerate}

To mitigate both of these problems, it is possible to execute
generation and translation steps concurrently.  The generation table
can be formalized as a finite state transducer that maps between
factors on the target language side. The phrase table can be
formalized as a finite state transducer (FST) that maps between
source language factors to target language factors.  Thus all
devices that generate a given target language factor can be
conceived of as FSTs.  These FSTs can be composed with well-known
algorithms that will generally run much more efficiently (this is
exactly the method that is used to minimize the paths searched
through confusion networks: the source-side of the phrase table is
treated as a finite state automaton that is intersected with the
confusion network).

\subsubsection{Hybrid multi-factor and single-factor models}

A characteristic feature of natural languages is that elements of a
wide variety of sizes, from sub-word morphemes to complete
sentential units may be lexicalized.  The larger lexicalized units
(for example, idioms and "stock phrases") frequently exhibit
idiosyncratic- rather than compositional- meaning and are the bread
and butter of conventional phrase-based machine translation systems.
The phrase model can simply "memorize" the larger units and their
corresponding translations, which often tend to be idiosyncratic in
the target language.  This is arguably one of the significant
benefits of conventional phrase-based translation models since
mistranslating common stock phrases results is significantly
diminished fluency and understanding, and common evaluation metrics
assign a great deal of value to correctly translated stock phrases
(since they are, by definition, several words in length and tend to
exhibit relatively fixed word order).

Multi-factored models that analyze the source language in terms of
underlying lemmas, parts of speech, and morphological information,
and then translate these factors in a piecemeal fashion may actually
result in a system that performs less well on commonly occurring
lexicalized phrases. There are at least two reasons for this. First,
the process of lexicalization results in the retention of archaic or
otherwise unusual forms, possibly in unusual configurations.  Thus,
when these units are analyzed, they exhibit unusual morphological
features and parts of speech.  These unusual features introduce
significant sparseness in the sequence models in the target language
and reduce the overall probability that would be assigned to a
correct translation.  Second, single-factored translation models
generally have very good data on lexicalized phrases (since they
must, in order to be acquired by language learners as lexicalized
elements, occur with a reasonable frequency).  Therefore even if the
underlying linguistic phenomena are rather unusual, they are well
modeled in both translation models and target language models.
Moreover, if the target translation does contain unusual items,
these are more likely to occur in a very specific context, which
will generally decrease the net language model cost that would
otherwise be expected for infrequently occurring items.

To retain the benefits associated with multi-factored models
(generalization across inflected forms, making use of data with
richer statistics) but retaining the benefits of single-factored
"surface" translation models (better handling of stock phrases), a
more effective method would be to allow both a surface form based
single-factored model to propose hypotheses for various spans in a
sentence that would compete with hypotheses generated by a
multi-factored model.  Since multi-factored models consist of
different models with different scoring functions, the costs
associated with the two classes of hypotheses are not directly
comparable.  To mitigate this difficulty and establish a trading
relation between the two classes of hypotheses, a single-factor
penalty parameter will be introduced that can be tuned along with
the other parameters used in decoding.


\chapter{Confusion Network Decoding}\label{chap:confusion-networks}
%{\sc Marcello Federico and Richard Zens: cut and paste from your journal paper?}

% Definitions.
% --------------------
\def\x{{\mathbf x}}
\def\L{{\cal L}}
\newcommand{\devfour}{{\tt dev4}}
\newcommand{\eval}{{\tt eval}}
\newcommand{\E}{{\bf e}}
\newcommand{\F}{{\bf f}}
\newcommand{\bm}[1]{{\mbox{\boldmath${#1}$}}}
\newcommand{\tf}{\tilde{f}}
\newcommand{\te}{\tilde{e}}
\newcommand{\teb}{{\bf \te}}


Machine translation input currently takes the form of simple sequences of words. 
However, there are increasing demands to integrate machine translation technology 
in larger information processing systems with upstream NLP/speech processing tools 
(such as named entity  recognizers, speech recognizers, morphological analyzers, etc.). 
These upstream processes tend to generate multiple, erroneous hypotheses with 
varying confidence.  Current MT systems are designed to process only one input 
hypothesis, making them vulnerable to errors in the input.  

\noindent
Our  focus in the workshop was on the speech translation case, where the input is 
generated by a speech recognizer.  More specifically, our goal was  to improve performance 
of spoken language translation by better integrating  speech recognition and 
machine translation  models. Translation from speech input is considered  more difficult than 
translation from text for several reasons. Spoken language has many  styles and 
genres, such as, formal read speech, unplanned speeches, interviews, spontaneous 
conversations;  it produces less controlled language, presenting more relaxed syntax 
and spontaneous speech phenomena. Finally, translation of spoken language is prone 
to speech recognition  errors, which can  possibly corrupt the  syntax and the meaning of 
the input.

The impact of speech recognition errors on translation performance
is explained by the plot in Figure~\ref{fig:wer-bleu}, which shows BLEU scores of 
translations together with the WER of the corresponding source sentences.  There is
also empirical evidence that better translations can be obtained from 
transcriptions of the speech recognizer which resulted indeed in lower scores.  This
suggests that improvements can be achieved by applying machine translation on 
a large set of transcription hypotheses generated by the speech recognizers and by
combining scores of  acoustic models, language models, and translation models.



Recently, approaches have been
proposed for improving translation quality  through the processing of 
multiple input hypotheses.  In particular, better translation performance 
have been reported by exploiting   $N$-best lists \cite{zhang04,quan05},  word 
lattices \cite{matusov05,mathias06},   and confusion networks \cite{bertoldi05a}.  

\noindent
In the workshop we concentrated on confusion network decoding as  discussed in  
\cite{bertoldi05a}, and  developed a simpler translation model and a  more efficient 
implementation of the search algorithm.  Remarkably, the confusion network decoder  
resulted in an extension of  the standard text decoder.

\section{Spoken language translation}
\label{sec:slt}
\noindent

\begin{figure}[t]
\begin{center}
\label{fig:wer-bleu}
\caption{Relationship between BLEU score of target strings and word-error-rate (WER) of source strings. 
Source strings are transcriptions of parliamentary speeches produced by a speech recognition system (To be checked) .}
\includegraphics[width=10cm]{marcello-bleu-wer} 
\end{center}
\end{figure}



From a statistical perspective, SLT can be approached as follows.
Given the  vector $\o$ representing  the acoustic observations  of the
input  utterance,   let  ${\cal  F(\o)}$  be  a   set  of
transcription  hypotheses  computed by  a speech recognizers  and
represented  as a  word-graph.   The  best translation  $\E^*$ is  
searched  among all  strings in  the target language ${\cal E}$ through 
the following criterion:
%\begin{eqnarray}
\begin{equation}
%\e^* &=& \arg\max_{\E} \sum_{\f \in {\cal F}(\o)} \Pr(\E, \f  \mid \o)
\E^* = \arg\max_{\E} \sum_{\F \in {\cal F}(\o)} \Pr(\E, \F  \mid \o)
\label{eq:slt-max}
%\end{eqnarray}
\end{equation}
where the source language sentence $\F$ is an hidden variable representing any speech transcription
hypothesis.   According to the well established log-linear framework, 
 the  conditional distribution $\Pr(\E,\F  \mid \o)$ can be  determined through suitable
real-valued  feature functions  $h_r(\E,\F,\o)$  and real-valued  parameters
$\lambda_r$, $r=1\ldots R$, and takes the parametric form:
\begin{equation} 
p_{\tiny \bm{ \lambda}}(\E ,\F \mid \o) = \frac{1}{{\cal Z}(\o)} \exp\left\{ \sum_{r=1}^R \lambda_r h_r(\E,\F,\o)\right\}
\label{eq:loglin} 
\end{equation}
where ${\cal Z}(\o)$ is a normalization term.

\noindent
The main advantage of the log-linear model defined in ({\ref{eq:loglin}) is
the possibility to use any kind of features, regarded as important for
the sake of translation. Currently,  better  performance  are  achieved by  defining
features  in  terms of  {\em  phrases} $\te$  \cite{zens02,koehn03,federico05a} instead of single words, 
and by searching the best translation $\teb^*$  among all  strings  of phrases 
in  a  defined vocabulary of phrases.

\noindent
The kind of representation used for the set of hypotheses  ${\cal F}(\o)$  clearly 
impacts on the implementation  of the search algorithm. Here, we assume to 
have all hypotheses represented as a confusion network.

\section{Confusion Networks}
\label{sec:cn}
\noindent
A Confusion Network (CN) ${\cal  G}$ is a weighted directed graph with
a start node, an end node, and word labels over its edges.  The CN has
the peculiarity  that each path  from the start  node to the  end node
goes    through    all    the    other    nodes.     As    shown    in
Figure~\ref{fig:CN-matrix}, a CN can be represented as a matrix of words
whose columns  have different depths.   Each word $w_{j,k}$  in ${\cal
G}$  is identified  by its  column  $j$ and  its position  $k$ in  the
column;  word   $w_{j,k}$  is  associated  to   the  weight  $p_{j,k}$
corresponding to the posterior probability $\Pr(f=w_{j,k} \mid \o, j)$
of  having  $f=w_{j,k}$ at  position  $j$  given  $\o$.  A realization 
$\F=f_1,  \ldots, f_m$ of ${\cal G}$  is associated with
the probability $\Pr(\F\mid \o)$, which is factorized as follows:
\begin{equation}
\Pr (\F \mid \o)= \prod_{j=1}^m \Pr(f_j\mid \o, j)
\label{eq:CN-posterior}
\end{equation}

\begin{figure}
\begin{center}
\begin{tabular}{c|c|c|c|c}
se$_{.97}$ &  presenta$_{.40}$  & $\epsilon_{.78}$& esas$_{.86}$& elecciones$_{.97}$\\
he$_{.03}$ &  present\'o$_{.22}$  & a$_{.08}$           & $\epsilon_{.10}$& selecciones$_{.03}$\\
                     &  presentan$_{.06}$ & e$_{.07}$            & esa$_{.04}$&     \\
                       &  $\ldots$                    & en$_{.06}$          &                     &    \\
                      &                                    & $\ldots$                &                      &\\
\end{tabular}
\end{center}
\caption{Example of confusion network.}
\label{fig:CN-matrix}
\end{figure}


\noindent
The  generation of  a CN  from an  ASR word-graph  \cite{mangu:00} can
also produce special empty-words $\epsilon$ in some columns. These
empty-words permit to generate source sentences of different length and 
are treated differently from regular words only at the level of feature functions.

\subsection{Generative translation process}
\label{sec:CN-gen}
\noindent
The following process describes how to incrementally generate a translation 
from a confusion network ${\cal G}$:
\bigskip

\noindent
\begin{tt}
While there are uncovered source columns\\
\indent A span of uncovered columns is covered\\
\indent A path inside the span is chosen\\
\indent A translation of the path is appended to the target\\
\end{tt}


\subsection{CN-based log-linear model}
\label{sec:cn-model}
\noindent
The log-linear model adopted for the CN decoder includes the following feature 
functions:
\begin{enumerate}
\item A word-based $n$-gram target LM.
\item A reordering model defined in terms of the distance  between the first column covered 
by current span and the last column of the previous span. (In the current implementation, we
did not distinguish between regular and empty words.)
\item Four phrase-based lexicon models exploiting statistics at word- and phrase-level. These models
remove any empty-word in the source side.
\item Phrase and word penalty models, i.e.  counts of the number of phrases and words in the target string.
\item The  CN posterior probability, see formula (\ref{eq:CN-posterior}).
\end{enumerate}

\noindent 
Notice that the above features can grouped into two categories: those which are expansion-dependent because their computation requires some knowledge about the previous step (i,ii), and those which are not (iii,iv,v).

\subsection{Decoding algorithm}
\label{sec:decoding}
\noindent
According  to  the {\em  dynamic  programming}  paradigm, the  optimal
solution can be computed through expansions and recombinations of  
previously computed  partial  theories.  With respect to translating a
single input hypothesis, translating from a CN requires, 
in principle, exploring all possible input paths inside the graph. 
A key insight is that, due to their linear structure, CN
decoding is very similar to text decoding.  During the
decoding, we have to look up the translation options of spans, i.e. some
contiguous sequence of source positions.  The main
difference between CN and text decoding is that in text
decoding there is exactly one source phrase per span, whereas in
confusion network decoding there can be multiple source phrases per
span.  In fact, in a CN the number of source phrases
per span is exponential in the span length, assuming its minimum depth is larger than one.

\noindent
The decoding algorithm can be made much more efficient by 
pre-fetching translations for all the spans and by applying  early recombination. 

\subsection{Early recombination}
\label{sec:early-rec}
\noindent
At each expansion step  a span covering a given number of consecutive columns is generated. 
Due to the presence of empty-words, different paths within the span can 
generate the same source phrase, hence the same translations. The scores of such 
paths only impacts on the CN posterior feature (v).  Additionally, it might happen that two 
different source phrases of the same span have a common translation. In this case, not only the CN 
posterior feature is different, but also the phrase translation features (iii).
This  suggests that efficiency can be gained by pre-computing all possible alternative
 translations for all possible spans, together with their expansion-independent scores, 
 and to recombine these translations in advance.  
  
\subsection{Pre-fetching of translation options} 
\label{sec:pre-fetching}
\noindent
Concerning the pre-fetching of translations from the phrase-table, an 
efficient implementation can be achieved if we use a prefix
tree representation for the source phrases in the phrase table and
generate the translation options incrementally over the span length.
So, when looking up a span $(j_1,j_2)$, we can exploit our knowledge
about the span $(j_1,j_2-1)$.  Thus, we have to check only for the
known prefixes of $(j_1,j_2-1)$ if there exists a successor prefix
with a word in column $j_2$ of the CN.  If all the word
sequences in the CN also occur in the phrase table,
this approach still enumerates an exponential number of phrases.  So,
the worst case complexity is still exponential in the span length.
Nevertheless, this is unlikely to happen in practice.  In our
experiments, we do not observe the exponential behavior.  What we
observe is a constant overhead compared to text input.



\section{$N$-best decoder}

A widely used  reference  for spoken language translation  is 
the so-called N-best  translation approach, which we used as a term
of comparison in our experiments.

\bigskip
\label{sec:1best-smt}
\noindent
An alternative way to define the set ${\cal F}(\o)$ is to take the $N$
most  probable hypotheses  computed by  the ASR  system,  i.e.  ${\cal
F}(\o)=\{\F_1, \ldots,\F_N\}$. By  taking a maximum approximation over
${\cal F}(\o)$, and assuming that $\Pr(\teb, \F \mid \o) = \Pr(\F\mid
\o)   \Pr(\teb   \mid  \F)$, we get the search criterion:
\begin{eqnarray}
\label{eq:nbest-max-1}
\teb^* &\approx& \arg\max_{n=1,..,N}    \Pr(\F_n \mid \o) \max_{\teb} \Pr(\teb \mid \F_n)
\label{eq:nbest-max}
\end{eqnarray}

\noindent
In the equation above we can isolate $N$ independent translation tasks 
(rightmost  maximization),  and   the  recombination  of  their  results
(leftmost maximization).  Hence, the search criterion  can be restated
as:
\begin{eqnarray}
\teb_n^* &=& \arg\max_{\teb} \Pr(\teb \mid \F_n)    \qquad n=1,\ldots, N \\
\teb^* &\approx& \arg\max_{n=1,..,N} \Pr(\F_n  \mid \o) \Pr(\teb_n^* \mid \F_n)
\label{eq:nbest-max-alg}
\end{eqnarray}

\noindent
In plain words: first the best translation $\teb_n^*$ of each
transcription hypothesis $\F_n$ is searched; then, the best
translation $\teb^*$ is selected among $\{\teb_1^*, \ldots,
\teb_N^*\}$ according to its score weighted by the ASR posterior
probability $\Pr(\F_n \mid \o)$.

\noindent
In the experimental chapters we will compare 
performance of the CN decoder against the above N-best approach, which 
besides the standard text translation model of Moses requires a second re-scoring pass. 
The resulting log-linear model for the $N$-best decoder 
is very similar  to the CN decoder. Specifically,  feature (v) is  replaced   %%% h_cn is never used before
 with two features corresponding to the log-probability of the acoustic and language model scores provided by the  ASR system.



\chapter{Open Source Toolkit}\label{toolkit}
\section{Overall design}
In developing the Moses decoder we were aware that the system should be open-sourced if it were to gain the support and interest from the machine translation community that we had hoped. There were already several proprietary decoders available which frustrated the community as the details of their algorithms could not be analysed or changed.
However, making the source freely available is not enough. The decoder must also advance the state of the art in machine translation to be of interest to other researchers. Its translation quality and runtime resource consumption must be comparable with the best available decoders. Also, as far as possible, it should be compatible with current systems which minimize the learning curve for people who wish to migrate to Moses. 
We therefore kept to the following principles when developing Moses: \\
\begin{itemize}	
 \item Accessibility 
 \item 	Easy to Maintain
 \item	Flexibility
 \item	Easy for distributed team development
 \item	Portability
\end{itemize}
The number of functionality added in the six weeks by every member of the team at the Johns Hopkins University workshop, as can be seen from the figures below, is evident that many of these design goals were met.

\begin{center}
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{hieu-1}
\caption{Lines of code contribute by each developer}
\end{figure}
\end{center}

By adding factored translation to conventional phrase based decoding we hope to incorporate linguistic information into the translation process in order to create a competitive system.\\

Resource consumption is of great importance to researchers as it often determine whether or not experiments can be run or what compromises needs to be taken. We therefore also benchmarked resource usage against another phrase-based decoder, Pharaoh, as well as other decoders, to ensure that they were comparable in like-for-like decoding.\\

It is essential that features can be easily added, changed or replace, and that the decoder can be used as a Ã¢Â€Â˜toolkitÃ¢Â€Â™ in ways not originally envisaged. We followed strict object oriented methodology; all functionality was abstracted into classes which can be more readily changed and extended. For example, we have two implementations of single factor language models which can be used depending on the functionality and licensing terms required. Other implementations for very large and distributed LMs are in the pipeline and can easily be integrated into Moses. The framework also allows for factored LMs; a joint factor and skipping LM are currently available.\\
\begin{center}
\begin{figure}[h]
\centering
\includegraphics[scale=1]{hieu-2}
\caption{Language Model Framework}
\end{figure}
\end{center}
Another example is the extension of Moses to accept confusion networks as input. This also required changes to the decoding mechanism.\\

\begin{center}
\begin{figure}[h]
\centering
\includegraphics[scale=1]{hieu-3}
\caption{Input}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{hieu-4}
\caption{Translation Option Collection}
\end{figure}
\end{center}
Nevertheless, there will be occasions when changes need to be made which are unforeseen and unprepared. In these cases, the coding practises and styles we instigated should help, ensuring that the source code is clear, modular and consistent to enable the developers to quickly assess the algorithms and dependencies of any classes or functions that they may need to change.\\

A major change was implemented when we decided to collect all the score keeping information and functionality into one place. That this was implemented relatively painlessly must be partly due to the clarity of the source code.\\

\begin{center}
\begin{figure}[h]
\centering
\includegraphics[scale=0.8]{hieu-5}
\caption{Scoring framework}
\end{figure}
\end{center}

The decoder is packaged as a library to enable users to more easily comply with the LGPL license. The library can also be embedded in other programs, for example a GUI front-end or an integrated speech to text translator.

\subsection{Entry Point to Moses library}

The main entry point to the library is the class\\
\\
\indent{\tt Manager}\\
\\
For each sentence or confusion network to be decoded, this class is instantiated and the following function called\\
\\
\indent{\tt ProcessSentence()}\\
\\
Its outline is shown below\\
\\
\begin{tt}
\indent CreateTranslationOptions()\\
\indent for each stack in m\_hypoStack\\
\indent \indent prune stack\\
\indent \indent for each hypothesis in stack\\
\indent \indent \indent ProcessOneHypothesis()\\
\end{tt}\\
Each contiguous word coverage (Ã¢Â€Â˜spanÃ¢Â€Â™) of the source sentence is analysed in\\ 
\indent {\tt CreateTranslationOptions() }\\
\\
and translations are created for that span. Then each hypothesis in each stack is processed in a loop. This loop starts with the stack where nothing has been translated which has been initialised with one empty hypothesis.
\\
\subsection{Creating Translations for Spans}
The outline of the function \\
\\
\indent {\tt TranslationOptionCollection::CreateTranslationOptions()}\\
\\
is as follows:\\
\\
\begin{tt}
\indent	for each span of the source input\\
\indent \indent	CreateTranslationOptionsForRange(span)\\
\indent	ProcessUnknownWord()\\
\indent	Prune()\\
\indent	CalcFutureScoreMatrix()\\
\end{tt}
\\
A translation option is a pre-processed translation of the source span, taking into account all the translation and generation steps required. Translations options are created in\\
\\
\indent {\tt CreateTranslationOptionsForRange()}
\\
which is out follows\\
\\
\begin{tt}
\indent	ProcessInitialTranslation()\\
\indent	for every subequent decoding step\\
\indent \indent	if step is Ã¢Â€Â˜TranslationÃ¢Â€Â™\\
\indent \indent \indent	DecodeStepTranslation::Process()\\
\indent \indent else if step is Ã¢Â€Â˜GenerationÃ¢Â€Â™\\
\indent \indent \indent DecodeStepGeneration::Process()\\
\indent Store translation options for use by decoder\\
\end{tt}
\\
However, each decoding step, whether translation or generation, is a subclass of\\
\\
\indent {\tt DecodeStep}\\
\\
so that the correct Process() is selected by polymorphism rather than using if statements as outlined above.
\subsection{Unknown Word Processing}
After translation options have been created for all contiguous spans, some positions may not have any translation options which covers it. In these cases, CreateTranslationOptionsForRange() is called again but the table limits on phrase and generation tables are ignored. \\
If this still fails to cover the position, then a new target word is create by copying the string for each factor from the untranslatable source word, or the string Ã¢Â€Â˜UNKÃ¢Â€Â™ if the source factor is null.\\
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Source Word & & New Target Word \\ \hline
Jimmy	& 	$\to$	& Jimmy\\
Proper Noun	& $\to$	& Proper Noun\\
-	& $\to$	& UNK\\
-	& $\to$	& UNK\\ \hline
\end{tabular}
\end{center}

This algorithm is suitable for proper nouns and numbers, which are one of the main causes of unknown words, but is incorrect for rare conjugation of source words which have not been seen in the training corpus. The algorithm also assumes that the factor set are the same for both source and target language, for instance, th list of POS tags are the same for source and target. This is clearly not the case for the majority of language pairs. Language dependent processing of unknown words, perhaps based on morphology. is a subject of debate for inclusion into Moses.\\
Unknown word processing is also dependent on the input type - either sentences or confusion networks. This is handled by polymorphism, the call stack is\\
\\
\begin{tt}
\indent	Base::ProcessUnknownWord()\\
\indent \indent	Inherited::ProcessUnknownWord(position)\\
\indent \indent \indent	Base::ProcessOneUnknownWord()\\
\end{tt}
where\\
\indent {\tt Inherited::ProcessUnknownWord(position)}\\
\\
is dependent on the input type.
\subsection{Scoring}
A class is created which inherits from\\
\\
\indent {\tt ScoreProducer}\\
\\
for each scoring model. Moses currently uses the following scoring models:\\
\\
\begin{center}
\begin{tabular}{|r|r|}
\hline
$ Scoring model $&$ Class $\\
\hline
Distortion	& DistortionScoreProducer\\
WordPenalty	& WordPenaltyProducer\\
Translation	& PhraseDictionary\\
Generation	& GenerationDictionary\\
LanguageModel	& LanguageModel\\
\hline
\end{tabular}\\
\end{center}

The scoring framework includes the classes \\
\\
\begin{tt}
\indent ScoreIndexManager\\
\indent	ScoreComponentCollection\\
\end{tt}
\\
which takes care of maintaining and combining the scores from the different models for each hypothesis.
\subsection{Hypothesis}
A hypothesis represents a complete or incomplete translation of the source. Its main properties are
\begin{center}
\begin{tabular}{|r|l|}
\hline
$ Variables $&$ $\\
\hline
m\_sourceCompleted & Which source words have already been translated\\
m\_currSourceWordsRange & Source span current being translated\\
m\_targetPhrase & Target phrase currently being used\\
m\_prevHypo & Pointer to preceding hypothesis that translated \\
 & the other words, not including m\_currSourceWordsRange\\
m\_scoreBreakdown & Scores of each scoring model\\
m\_arcList & List of equivalent hypothesis which have lower\\
 & score than current hypothesis\\
\hline
\end{tabular}\\
\end{center}

Hypothesis are created by calling the constructor with the preceding hypothesis and an appropriate translation option. The constructors have been wrapped with static functions, Create(), to make use of a memory pool of hypotheses for performance.\\
\\
Many of the functionality in the Hypothesis class are for scoring. The outline call stack for this is\\
\\
\begin{tt}
\indent CalcScore()\\
\indent	\indent	CalcDistortionScore()\\
\indent	\indent	CalcLMScore()\\
\indent	\indent	CalcFutureScore()\\
\end{tt}
\\
The Hypothesis class also contains functions for recombination with other hypotheses. Before a hypothesis is added to a decoding stack, it is compare to other other hypotheses on the stack. If they have translated the same source words and the last n-words for each target factor are the same (where n is determined by the language models on that factor), then only the best scoring hypothesis will be kept. The losing hypothesis may be used latter when generating the n-best list but it is otherwise not used for creating the best translation.\\
\\
In practise, language models often backoff to lower n-gram than the context words they are given. Where it is available, we use information on the backoff to more agressively recombine hypotheses, potentially speeding up the decoding.\\
\\
The hypothesis comparison is evaluated in \\
\\
\indent {\tt NGramCompare()}\\
\\
while the recombination is processed in the hypothesis stack class\\
\\
\indent {\tt HypothesisCollection::AddPrune()}\\
\\
and in the comparison functor class\\
\\
\indent {\tt HypothesisRecombinationOrderer}
\subsection{Phrase Tables}	
The main function of the phrase table is to look up target phrases give a source phrase, encapsulated in the function\\
\indent {\tt PhraseDictionary::GetTargetPhraseCollection()}\\
There are currently two implementation of the PhraseDictionary class\\
\begin{tabular}{|l|l|}
\hline
PhraseDictionaryMemory & Based on std::map. Phrase table loaded\\ 
 & completely and held in memory\\
PhraseDictionaryTreeAdaptor & Binarized phrase table held on disk and \\
 & loaded on demand.\\
\hline
\end{tabular}
\subsection{Command Line Interface}
The subproject, moses-cmd, is a user of the Moses library and provides an illustration on how the library functions should be called. It is licensed under a BSD license to enable other users to copy it source code for using the Moses library in their own application.\\
\\
However, since most researchers will be using a command line program for running experiments, it will remain the defacto Moses application for the time being.\\
\\
Apart from the main() function, there are two classes which inherites from the moses abstract class, InputOutput:\\
\\
\indent {\tt	IOCommandLine}\\
\indent {\tt	IOFile (inherites from IOCommandLine)}\\
\\
These implement the required functions to read and write input and output (sentences and confusion network inputs, target phrases and n-best lists) from standard io or files.





\section{Software Engineering Aspects}

\subsection{Regression Tests}
Moses includes a suite of regression tests designed to ensure that
behavior that has been previously determined to be correct does not
break as new functionality is added, bugs are fixed, or performance
improvements are made. The baseline behavior for the regression
testing is determined in three ways:
\begin{enumerate}
  \item Expected behavior based on off-line calculations (for example,
  given a small phrase table and sample input, one can work through
  the search space manually and compute the expected scores for a translation hypothesis).
  \item Expected values based on comparisons with other systems (for
  example, language modeling toolkits provide the ability to score
  a sentence.  Such a tool can be used to calculate the expected value of
  the language model score that will be produced by the decoder).
  \item Expected values based on previous behavior of the decoder (some output behavior
  is so complex that it is impractical or impossible to determine externally
  what the expected values are; however, it is reasonable to assume that localized bug-fixes,
  the addition of new functionality, or performance improvements should not impact existing
  behavior).
\end{enumerate}
The nature of statistical machine translation decoding makes
achieving substantial and adequate test coverage possible with
simple black-box testing.  Aggregate statistics on the number of
hypotheses generated, pruned, explored, as well as comparisons of
the exact costs and translations for certain sample sentences
provide ample evidence that the models and code that is utilized in
decoding is working adequately since these values tend to be highly
sensitive to even minor changes in behavior.

\subsubsection{How it works}
The test harness (invoked with the command \texttt{run-test-suite})
runs the decoder that is to be tested (specified to the script with
the \texttt{--decoder} command line option) with a series of
configuration files and translation inputs.  The output from the
decoder, which is written to \texttt{stdout} and \texttt{stderr}, is
post-processed by small scripts that pull out the data that is going
to be compared for testing purposes.  These values are compared with
the baseline and a summary is generated.

Timing information is also provided so that changes that have
serious performance implications can be identified as they are made.
This information is dependent on a variety of factors (system load,
disk speed), so it is only useful as a rough estimate.
\subsubsection{Versioning}
The code for the regression test suite is in the
\texttt{regression/tests} subdirectory of the Subversion repository.
 The inputs and expected values for each test case in the test suite are stored
together in \texttt{regression-tests/tests}.  The test suite is
versioned together with the source code for several reasons:
\begin{enumerate}
  \item As bugs are identified and fixed that effect existing behavior, the
testing code needs to be updated.
  \item As new functionality is added, testing code exercising this functionality needs to be
  added (see below for more details).
\end{enumerate}
By versioning the regression tests together with the source code, it
should be possible to minimize when developers need to worry about
expected test failures.

The data (language models, phrase tables, generation tables, etc.)
that is used by the individual test cases is versioned along with
the source code, but because of its size (currently about 60MB), it
is not stored in Subversion.  When test suite is run in a new
environment or one with an improper version of the test data, it
will fail and provide instructions for retrieving and installing the
proper version of the testing data (via HTTP) from the test data
repository, which is currently \texttt{http://statmt.org}.

\subsubsection{Making changes to existing tests}
As changes are made that effect the decoder's interface (output
format, command line interface, or configuration file format) and
bugs that effect existing decoder behavior are fixed, it will often
be necessary to update either the expected values, the scripts that
post-process the decoder output, or the configuration files.  These
files can be edited in the same manner as the rest of the source
code and should be submitted along with the corresponding code
changes.

If changes need to be made to the test data, a new tar-ball must be
generated that contains all of the test data for all regression
tests and submitted to the repository maintainer.  Once it is
available for download, the \texttt{TEST\_DATA\_VERSION} constant in
\texttt{MosesRegressionTesting.pm} can be incremented to point to
the new version.

\subsubsection{Adding regression tests}
As new functionality is incorporated into Moses, regression tests
should be added that guarantee that it will continue to be behave
properly as further changes are made.  Generally, testing new models
with multi-factored models is recommended since common
single-factored models exercise only a subset of the logic.

If new regression tests have new data dependencies, the test data
will need to be updated.  For more information on this workflow,
refer to the previous section.

\subsection{Accessibility}
The source code for the Moses project is housed at Sourceforge.net
in a subversion repository.  The URL for the project is:

\begin{quote}
    \texttt{http://sourceforge.net/projects/mosesdecoder/}
\end{quote}

The source code is publicly accessible and in two ways:
\begin{enumerate}
  \item Pre-packaged tar-balls are available for download directly
  from project page at Sourceforge.
  \item The current development source code can be accessed with a subversion client (see \texttt{http://subversion.tigris.org/}
for more details how to acquire and use the client software).
\end{enumerate}


\subsection{Documentation}
{\sc Philipp Koehn and Chris Callison-Burch: Doxygen}

\section{Parallelization}
%{\sc Nicola Bertoldi}
The decoder implemented in {\tt Moses} translates its input sequentially; in order to increase 
the speed of the toolkit a parallelization module was developed which exploits several instances of the decoder and feed them with subsets of the scource input.


\begin{figure}
\begin{center}
 \includegraphics[width=\columnwidth]{Moses-parallel}
\caption{The parallelization module for {\tt Moses}.}
\label{fig:parallel}
\end{center}
 \end{figure}
 
As shown in Figure~\ref{fig:parallel}, the procedure we implemented is reasonably easy:
first, the source input is equally divided into $N$ parts, then $N$ instances of the {\tt Moses} translate them; finally, the full translation is obtained by ordering and merging the translation of all input parts.

All {\tt Moses} instances are assumed to run on a (possibly remote) cluster. No restriction on the number of {\tt Moses} instances is given.


Time to perform a full translation with one {\tt Moses} instance comprises the time to load data, which is constant, and time to translate the input, which is proportional to its size.
The parallelization module requires an additional time to access the cluster, which is strictly related to the real load of the cluster itself and hardly forecastable.
Time to split the input and merge the output can be considered negligible with respect to the translation time.
Moreover, an "ending" delay can be observed because the merging module should wait that all decoders have completed their translations, and this does not necessarily happen at the same time. A good splitting policy which allows a balanced translation time among all decoders,  improves the effciency of the whole parallelization module.

We tested the gain in time that  the parallelization module can provide to the toolkit on the Spanish-English EuroParl task. 3 input sets were created of 10, 100 1000 sentences and translated using a standalone  {\tt Moses}, and the parallelization module exploiting difference number of {\tt Moses} instances (1, 5, 10, 20).
Decoders ran on the 18-processor CLSP cluster. As in the real situation, its load was not in control, and hence the immediate availability of the processors was not assured. Table~\ref{tbl:parallel-time} reports the average translation times for all conditions.

Some considerations can be drawn by inspecting these figures.
\begin{itemize}
\item Parallelization is uneffective if source input is small, because time to access the cluster becomes prevalent.
\item Trivially, there is no reason of using the parallelization module if just one processor is required. 
\item Parallelization is beneficial if more instances of {\tt Moses} are exploited.
\item The gain in time is not exactly proportional to the number of decoder instances, mainly due to the effect  of "ending" delay.
\end{itemize}


\begin{table}
\label{tbl:parallel-time}
\begin{center}
\begin{tabular}{r|rrrrr}
                 & standalone   &1 proc  & 5 proc  &  10 proc   &  20 proc\\
                 \hline
     10 sentences   &  6.3  &  13.1 &  9.0  &  9.0   &     --  \\
  100 sentences   &  5.2  &  5.6    &  3.0  &  1.7   &   1.7 \\
1000 sentences   & 6.3   &  6.5    &  2.0  &  1.6   &   1.1 \\
\end{tabular}
\caption{Average time (seconds) to translate 3 input sets with a standalone {\tt Moses} and with its parallel version.}
\end{center}
\end{table}

In conclusion, the choice of the number of splits $N$ is essential for a good efficiency of the parallelization module, and depends on the available computational power, the cluster load, and the average translation time of the standalone decoder.



\section{Tuning}
\label{merttuning}
%{\sc Nicola Bertoldi}
\newcommand{\e}{{\bf e}}
\newcommand{\f}{{\bf f}}
\label{sec:tuning}
As described in Section~\ref{sec:slt}, {\tt Moses} decoder relies on a log-linear model to search for the best translation $\e^*$ given an input string $\f$:
\begin{equation}
\e^* = \arg\max_{\e}  \Pr(\e \mid \f) =\arg\max_{\e}  p_{\lambda}(\e \mid \f) = \arg\max_{\e} \sum_i \lambda_i h_i(\e,\f)
\end{equation}

Main components of a  log-linear model are the real-valued feature functions $h_i$ and their real-valued weights $\lambda_i$. To get the best performance from this model all components need to be estimated and optimized for the specific task the model is applied to.

Feature functions model specific aspects of the translation process, like the fluency, the adequacy, the reordering. Features can correspond to any function of $\e$ and $\f$, and  there is no restriction about the values they assume.
Some features are  based on statistical models which are estimated on specific training data.

Feature weights are useful to balance the (possibly very different) ranges of the feature functions, and to weigh their relative relevance. The most common way to estimate the weights of a log-linear model is called Minimum Error Rate Training (MERT). It consists in an automatic procedure which search for the weights minimizing translation errors on a development set.

In this section we assume that the input type is text string, but trivially there is no matter if input is a Confusion Network, because MERT just estimates weights of the log-linear combination regardless the type and the number of features.


Let $\f$ be a source sentence and ${\bf ref}$ the set of its reference translations; 
let $\bf Err(\e;ref)$ be an error function which measures the quality of a given translation $\e$ with respect to the references ${\bf ref}$. The MERT paradigm can be formally stated as follows:

\begin{eqnarray}
\e^*= \e^*(\lambda) = \arg\max_{\e}  p_{\lambda}(\e \mid \f) \\
\bf \lambda^* = \arg\min_{\lambda} {\bf Err} (\e^*(\lambda);ref)
\label{eq:directMT}
\end{eqnarray}
where $\e^*(\lambda)$ is the best translation found by the decoder exploiting a given set of weights $\lambda$.

The error function needs to be computed automatically from $\e$ and ${\bf ref}$ without human intervention. Word Error Rate (WER), Position Independent Word Error Rate (PER), (100-BLEU score), -NIST score, or any combination of them are good candidates as automatic scoring functions. Notice that MERT minimizes an error function so quality measures need to be transformed accordingly.

An error function is rarely mathematically sound, and hence an exact solution of the previous problem is not usually known. Hence, algorithms like the gradient descent or the downhill simplex, are exploited which iteratively approximate the optimal solution. Unfortunately, these approximate algorithms just assure to find a local optimum.

\begin{figure}
\begin{center}
 \includegraphics[width=\columnwidth]{MER-ext}
\caption{An high-level picture of the Minimum Error Rate Training module for the optimization of the feature weights.}
\label{fig:MERT}
\end{center}
 \end{figure}
 
The MERT procedure we implemented during the workshop is depicted in Figure~\ref{fig:MERT}. 
It is based on two nested loops, which are now described.

In the outer loop 
\begin{enumerate}
\item initial weights $\lambda^0$, an empty list of translation hypotheses $T^0$, and the iteration index $t=0$ are set;
\item {\tt Moses} translates the input with  $\lambda^t$ and generates a list of $N$-best translation hypotheses $T^t$;
\item $T^t$ are added to the previous lists $T^0, \ldots T^{t-1}$;
\item the inner loop is performed (see below) on the new list $\bigcup_{i=0}^{t}T^i$ and with the weights $\lambda^t$;
\item the  new set of weights $\lambda^{t+1}$ provided by the inner loop are set;
\item t is increased by 1, and the loop restarts from 2.
\end{enumerate}
The outer loop ends when the list of translation hypotheses does not increase anymore.

In the inner loop which  is fed with a list of hypotheses and a set of weights $\bar \lambda$
\begin{enumerate}
\item initial weights $\lambda^0$ are set to $\bar \lambda$, and the iteration index $s=0$ is set;
\item all translation hypotheses in the list are rescored according with the actual weights $\lambda^s$
and the best-scored hypothesis is extracted ({\tt Extractor});
\item the error measure of such translation is computed ({\tt Scorer});
\item the {\tt Optimizer} suggests a new set of weights $\lambda^{s+1}$;
\item $s$ is increased by 1, and the loop restarts from 2.
\end{enumerate}
The inner loop ends when the error measure does not improve anymore.
As the {\tt Optimizer} provides a local optimum for the weights, and strongly depends on the starting point $\bar \lambda$, the inner loop starts over several  times with different choices of $\bar \lambda$. The first time the weights $\lambda^t$ used by {\tt Moses} in the last outer loop are applied; the next times random sets are exploited. The best set of weights are then provided to the outer loop again.

Instead of standard approximate algorithms like the gradient descent or the downhill simplex, in the workshop we employed an {\tt Optimizer} based on the idea proposed by \cite{och:03} and developed by David Chiang (USC-ISI). The algorithm strongly relies on the availability of a finite list of translation alternatives, because this allows a discretization of the $r$-dimensional space of the weights ($r$ is the number of weights). This makes the search of the optimum  faster. The algorithm iteratively optimizes one weight at a time.

The {\tt Scorer} employed in the workshop computes BLEU score.

The time spent for each iteration of the outer is basically proportional to the size of the input  because the translation of the whole input is required. The time for each iteration of the inner loop is proportional to the amount of translation hypotheses because all of them have to be re-scored and evaluated,



\section{Efficient Language Model Handling}
%{\sc Marcello Federico}

In this section we review main concepts related to the handling of language models (LMs) 
at run time, that is during the decoding phase. Concerning the estimation of language 
models the reader can refer to the documentation of publicly available tools, such as 
SRI LM Toolkit and the CMU-Cambridge SLM toolkit.  These toolkits, in general, provide many 
methods for estimating n-gram probabilities and are capable of generating  a static 
representation of an n-gram LM, a text or binary file, that can  be used within other programs.   

The motivation of developing software for handling LMs at run time is that efficiency, both 
in time and space, can be gained by exploiting peculiarities  of the way they are used by the 
hosting program, namely the decoder.  

The need for efficient LM handling comes from the  intrinsic data-sparseness of language corpora. 
Empirically, for a given size of n-grams,   the set of
observations increases  almost linearly with the size  of the training
data.  Hence, the trend of using larger and larger training corpora compels for careful memory
usage.

In general, to efficiently  store observations and probabilities in a
computer  memory the  following approaches  can be  tackled:  pruning  rare or unreliable observations, designing compact data-structures,  and applying data compression. While the observation pruning is typically embedded in the tools to estimate the LMs, we focused
on the other aspects, which are more related to the way the LM is used by a specific program.

In the following we discuss some of the features of our implementation: the representation of 
n-gram LMs, the quantization of probabilities, and  the use of cache memories. 

\subsection{LM representation}
In our implementation N-gram are stored in a data structure which indeed privileges memory
saving rather than access time.  In particular, single components of each n-grams are accessed 
via binary search and stored with 3 bytes, probabilities and back-off weights are instead stored
in 4 bytes, namely  floating point numbers. Improvements in memory savings are obtained by 
quantizing both back-off weights and probabilities. 

\begin{figure}
\begin{center}
 \includegraphics[width=\columnwidth]{marcello-lmstruct}
\caption{Data structure for storing n-gram language models.}
\label{fig:LM-struct}
\end{center}
 \end{figure}


\subsection{Probability quantization}

Quantization provides an effective way of reducing the number of bits
needed to store floating point variables. The quantization process
consists in partitioning the real space into a finite set of $k$ {\em
quantization levels} and identifying a center $c_i$ for each level,
$i=1,\ldots, k$. A function $q(x)$ maps any real-valued point $x$ onto
its unique center $c_i$.  Cost of quantization is the approximation
error between $x$ and $c_i$. 

Previous  experiments (cite ) suggested us to apply the so-called
binning method.  The binning method partitions data points into uniformly
populated intervals or {\em bins}. The center of each bin corresponds
to the mean value of all points falling into it.  If $N_i$ is the
number of points of the $i$-th bin, and $x_i$ the smallest point in
the $i$-th bin, a partition $[x_i,x_{i+1}]$ results such that $N_i$ is
constant for each $i=0,\ldots, k-1$, where $x_k=1$ by default.
The following map is thus defined:
$$q(x)=c_i \mbox{ if } x_i<=x<x_{i+1}.$$

In particular, our implementation uses the following {\em greedy} strategy: bins are
build by uniformly partition all different points of the data set.  Finally, quantization is 
applied separately at each n-gram level and for each kind of score, that is probabilities
or back-off weights.  The level of quantization is set to 8 bits, that experimentally showed 
to cause  no measurable loss in performance.

Quantization can be applied on any LM represented with the ARPA format. Quantized LMs
can be converted into a binary format that can be efficiently uploaded at decoding time.


\subsection{Caching of probabilities}

In order to overcome limitations of access time, caching is applied. The potential advantage
of caching during MT decoding is made evident by the plot in Figure~\ref{fig:LM-calls}. 
It shows all calls of 3-gram probabilities by the search algorithm during the decoding of
the following German sentence:

{\em ich bin kein christdemokrat und glaube daher nicht an wunder . doch ich m\"ochte dem europ\"aischen parlament , so wie es gegenw\"urtig beschaffen ist , f\"ur seinen grossen beitrag zu diesen arbeiten danken.}

During decoding of the sentence, about 120,000 different 3-grams are called for a total 
of about  1.7 million times.  The fact that a relatively small subset of 3-grams is frequently
accessed for each sentence suggest to store all of them into a cache. Each time a new 
sentence is decoded, the cache is reset and n-gram probabilities are added as soon as they are 
needed.  Additional caches are also used to store LM states, and all partial  n-grams 
searched in the data in order to limit the number of binary searches performed.

\begin{figure}
\begin{center}
 \includegraphics[width=\columnwidth]{marcello-lmcalls}
\caption{LM calls during decoding of a sentence by Moses.}
\label{fig:LM-calls}
\end{center}
 \end{figure}

\section{Lexicalized Reordering Models}
\section{Distortion Models} %draft 0.01
Distortion modeling is  used as a feature function in our translation system adding in a score based on the likely placement of a phrase relative to an adjacent phrase. Two main forms of distortion modeling are used in contemporary state of the art machine translation systems: distance distortion models, which penalize based on the distance of the reorder, and lexical distortion models, which take into account the relationship between the phrase being reordered and adjacent phrases. Moses extends lexical distortion models to factor distortion models, models in which lexical distortion serves as the special case using the surface forms as the factors in the probability distribution table.
\subsection{Distance Distortion Models}

Distance based distortion models consider the number of words over which the phrase is moved, as measured on the foreign side. An exponential penalty of $\delta^n$ for movements over n words is added.\cite{koehn:05} This distortion model has its limitations, especially in languages such as German and Japanese where reordering over greater distances is more common. Furthermore, some words are more acceptable to be reordered than others; for example an adjective such as ``white'' may often be reordered in a language in which adjectives appear in a different relative word order to English. A distance distortion model still offers a good starting point for distortion modeling; in fact, capping movement to approximately 4 words leads to BLEU score improvement, even in languages with relatively free word order.\cite{koehn:05}
\subsection{Lexical Distortion Models}

Many of the limitations of distance based distortion modeling are addressed in lexical distortion models\cite{tillmann:04, koehn:05}, which directly learn the probabilities for a given phrase being reordered relative to adjacent phrases. When collecting phrase pairs we can classify phrases as monotone, swap, or discontinuous based upon the relative placement of the phrases.\\
\indent $\bf{Monotone}$\\
\indent \indent Forward: word alignment point on bottom right\\
\indent \indent Backward: word alignment point on top left\\
\indent $\bf{Swap}$\\
\indent \indent Forward: word alignment point on bottom left\\
\indent \indent Backward: word alignment point on top right\\
\indent $\bf{Discontinuous}$\\
\indent \indent Not monotone or swap\\
Based upon this data, we calculate probability distributions of the form 
\begin{equation}
p_r(orientation|\bar{e},\bar{f})
\end{equation}
The design space for such a model is inherently larger, and three important design decisions are made in configuring the model, granularity of orientation distinction, side of the translation to condition the probability distribution on, and the directions of orientation to consider. Namely, one can distinguish between all three orientation classes or merely between monotone and non-monotone; one can condition the orientation probability distribution on the foreign phrase or on both the foreign and the source phrase; and one can model with respect to the previous phrase, the following phrase or both. Incorporating a lexical reordering model generally offers significant BLEU score improvements and the optimal configuration depends on language pair \cite{KoehnIWSLT05}. Lexical reordering was analogously implemented in Moses, offering the significant gains in BLEU score detailed below.\\

\begin{tabular}{r|rrr}
Europarl Lang & Pharaoh & Moses\\ 
\hline
 En $\rightarrow$ De & 18.15 &18.85 \\ 
Es $\rightarrow$ En & 31.46 & 32.37 \\
En $\rightarrow$ Es &  31.06 & 31.85 \\
\end{tabular}
\subsection{Factor Distortion Models}
Hard-coding in a few factor based distortion rules to an existing statistical machine translation system, such as forcing the swap of nouns and adjectives when translating from English to Spanish, improves translation quality as measured by the BLEU score \cite{pop:06}. This is a motivating result for the development factor distortion models which statistically learn and apply such rules in an analogous manner to the lexical distortion model detailed above.

In factor distortion models we define a reordering model over an arbitrary subset of factors. For example, a part of speech factor distortion model has the ability to learn in a given language that the probability of an adjective being swapped with a noun is high, while the probability of an adjective being swapped with a verb is low. As compared with distance or lexical distortion models, generalizing through a factor distortion model makes better use of the available training data and more effectively models long range dependencies. If we encounter a surface form we have not seen before, we are more likely to handle it effectively through information obtained from its factors. In addition, t is more likely we will have seen a sequence of general factors corresponding to a phrase in our training data than the exact lexical surface form of the phrase itself. As such, by having longer phrases of factors in our training data we have access to reordering probabilities over a greater range, enabling us in turn to model reordering over a greater number of words.

\subsection{Future work}
While factor distortion modeling is integrated into the machinery Moses, its possible limitations and considerable powers are ripe to be fully explored. Which combination of factors is most effective and which model parameters are optimal for those factors; furthermore, are the answers to these questions language specific, or is a particular configuration the clear forerunner?\\


\section{Error Analysis}
We describe some statistics generally used to measure error and present two error analysis tools written over the summer.

\subsection{Error Measurement}
There are three common measures of translation error. BiLingual Evaluation Understudy (BLEU) (\cite{bleu}), the most common, measures matches of short phrases between the translated and reference text as well as the difference in the lengths of the reference and output. BLEU can be applied to multiple references, but in a way such that BLEU scores using different numbers of references are not comparable.

Word Error Rate (WER) measures the number of matching output and reference words given that if output word $i$ is noted as matching reference word $j$, output word $i + 1$ cannot match any reference word before $j$; i.e., word ordering is preserved in both texts. Such a mapping isn't unique, so WER is specified using the maximum attainable number of single-word matches. This number is computable by some simple dynamic programming.

Position-Independent Word Error Rate (PWER) simply counts matching output and reference words regardless of their order in the text. This allows for rearrangement of logical units of text, but allows a system to get away with poor rearrangement of function words.

All these measures are highly dependent on the level of redundancy in the target language: the more reasonable translation options, the less likely the one chosen will match the reference exactly. So the scores we use are really comparable only for a specific source text in a specific language.

Perplexity (defined in \cite{perplexity}), measured for a text with respect to a language model, is a function of the likelihood of that text being produced by repeated application of the model. In a shaky sense, he higher the perplexity of a text, the more complex it is, so the harder it is to produce. The perplexity of the output of a modern machine translation system is usually lower (for our test case, by a factor of two to three) than that of a reliable reference translation. This is unsurprising because the people who provide the references have at their command long-range syntactic constructs that haven't been reconstructed via computer.

Along with these statistics, we'd like some assurance that they're stable, preferably in the form of confidence intervals. We use both the paired $t$ test and the more conservative sign test to obtain confidence intervals for the BLEU score of each translation system on a corpus.

All of these measures can be applied to a text of any size, but the larger the text, the more statistical these scores become. For detail about the kinds of errors a translation system is making, we need sentence-by-sentence error analysis. For this purpose we wrote two graphical tools.

\subsection{Tools}
While working on his thesis Dr. Koehn wrote an online tool that keeps track of a set of corpuses (a corpus is a source text, at least one system output and at least one reference) and generates various statistics each time a corpus is added or changed. Before the workshop, his system showed BLEU scores and allowed a user to view individual sentences (source, output, reference) and score the output. For large numbers of sentences manual scoring isn't a good use of our time; the system was designed for small corpuses. To replace the manual-scoring feature we created a display of the BLEU scores in detail for each sentence: counts and graphical displays of matching n-grams of all sizes used by BLEU. See figure \ref{fig:sentence_by_sentence_screenshot} for screenshots.

The overall view for a corpus shows a list of files associated with a given corpus: a source text, one or more reference translations, one or more system translations. For the source it gives a count of unknown words in the source text (a measure of difficulty of translation, since we can't possibly correctly translate a word we don't recognize) and the perplexity. For each reference it shows perplexity. For each system output it shows WER and PWER, the difference between WER and PWER two for nouns and adjectives only (\cite{errMeasures}), the ratio of PWER of surface forms to PWER of lemmas (\cite{errMeasures}), and the results of some simple statistical tests, as described above, for the consistency of BLEU scores in different sections of the text. The system handles missing information decently, and shows the user a message to the effect that some measure is not computable. Also displayed are results of a $t$ test on BLEU scores between each pair of systems' outputs, which give the significance of the difference in BLEU scores of two systems on the same input.

\begin{figure}[h]
\centering
\caption{Sample output of corpus-statistics tool.}
\label{fig:sentence_by_sentence_screenshot}
%temp removed to encourage document to compile
%\subfloat[detailed view of sentences]{\frame{\vspace{.05in}\hspace{.05in}\includegraphics[width=6in]{images/sentence-by-sentence_multiref_screenshot.png}\hspace{.05in}\vspace{.05in}}} \newline
%\subfloat[overall corpus view]{\frame{\vspace{.05in}\hspace{.05in}\includegraphics[width=6in]{images/corpus_overview_screenshot_de-en.png}\hspace{.05in}\vspace{.05in}}}
\end{figure}

A second tool developed during the workshop shows the mapping of individual source to output phrases (boxes of the same color on the two lines in figure \ref{fig:phrases_used_screenshot}) and gives the average source phrase length used. This statistic tells us how much use is being made of the translation model's capabilities. There's no need to take the time to tabulate all phrases of length 10, say, in the training source text if we're pretty sure that at translation time no source phrase longer than 4 words will be chosen.

\begin{figure}[h]
\centering
\caption{Sample output of phrase-detail tool.}
\label{fig:phrases_used_screenshot}
\frame{\vspace{.05in}\hspace{.05in}\includegraphics[width=5in]{images/show-phrases-used_crossover_screenshot.png}\hspace{.05in}\vspace{.05in}}
\end{figure}

%{\sc Evan Herbst}

\chapter{Experiments}

\section{English-German}
{\sc Philipp Koehn, Chris Callison-Burch, Chris Dyer}
\section{English-Spanish}
{\sc Wade Shen, Brooke Cowan, Christine Moran}

\section{English-Czech}
{  % wrapping all Ondrej's content to prevent confusing macros
%{\sc Ond\v{r}ej Bojar}


\def\clap#1{\hbox to 0pt{\hss #1\hss}}
\def\equo#1{``#1''}
\def\ang#1{{$\langle${#1}$\rangle$}}  % snadny zapis spicatych zavorek
\def\text#1{{\it{}#1}}


\def\bidir{Czech$\leftrightarrow$English}
\def\tocs{English$\rightarrow$Czech}
\def\toen{Czech$\rightarrow$English}
\def\parcite#1{(\cite{#1})}
\def\perscite#1{\cite{#1}} % works like newcite

\def\max#1{{\bf{} #1}}
\def\stddev#1{{$\pm$#1}}


\def\subsubsubsection#1{\bigskip{}{\it #1\\}}


This report describes in detail our experiments on \bidir{} translation
with the Moses system carried out at Johns Hopkins University
Summer Workshop 2006 in Baltimore. The reader is expected to be
familiar with factored translation models as implemented in Moses.

Section \ref{data} describes the data used for our experiments, including
preprocessing steps and some basic statistics. Section \ref{baselines}
introduces the metric and lists some known result on MT quality on our
dataset, including the scores of human translation. The core of this report is
contained in Section \ref{experiments} where all our experiments and results are
described in detail.




\subsection{Data Used}
\label{data}




\subsubsection{Corpus Description and Preprocessing}
\label{tools}


The data used for \bidir{} experiments are available as CzEng 0.5
\parcite{czeng:pbml:2006} and PCEDT 1.0 \parcite{pcedt:2004}. The collection contains parallel texts from various domains, as
summarized in Table~\ref{czengratios}.


\begin{table}[ht]
\begin{tabular}{lrr|rr}
  &  \multicolumn{2}{c}{Sentences}  &  \multicolumn{2}{c}{Tokens}\\
  &  Czech                             &  English                          &  Czech  &  English\\
\hline
Texts from European Parliament         &  77.7\%  &  71.7\%  &  78.2\%  &  75.9\%\\
E-Books                                &  5.5\%   &  6.6\%   &  7.2\%   &  7.4\%\\
KDE (open-source documentation)        &  6.9\%   &  10.2\%  &  2.6\%   &  3.6\%\\
PCEDT-WSJ (Wall Street Journal texts)  &  1.5\%   &  1.7\%   &  2.6\%   &  2.8\%\\
Reader's Digest stories                &  8.4\%   &  9.7\%   &  9.4\%   &  10.3\%\\
\hline
Total                                  &  1.4 M   &  1.3 M   &  19.0 M  &  21.6 M\\
\end{tabular}
\caption{Domains of texts contained in full training data.}
\label{czengratios}
\end{table}

The texts in CzEng are pre-tokenized and pre-segmented (sentence boundaries identified) and
automatically sentence-aligned using the hunalign tool
\parcite{varga:hunalign:2005}. The
PCEDT data are manually sentence aligned 1-1 by origin, because the Czech
version of the text was obtained by translating English text sentence by
sentence.

For the purposes of our experiments, we processed the data using the tools
listed in Table \ref{toolsused}.
The English side of the corpus had to be retokenized (keeping CzEng sentence
boundaries), because the original tokenization was not compatible with the tagging tool.

\begin{table}[ht]
\begin{center}
\small
\begin{tabular}{lcc}
  &  Czech  &  English\\
\hline
Segmentation  &  CzEng  &  CzEng\\
Tokenization  &  CzEng  &  \clap{Like Europarl, \cite{koehn:europarl:mtsummit:2005}}\\
Morph./POS Tagging  &  \cite{hajhla:1998b}  &  \cite{mxpost:1996}\\
Lemmatization  &  \cite{hajhla:1998b}  &  -not used-\\
Parsing  &  \cite{mcdonald:pereira:ribarov:hajic:2005}  &  -not used-\\
\end{tabular}
\end{center}
\caption{Czech and English tools used to annotate CzEng data.}
\label{toolsused}
\end{table}



\subsubsection{Baseline (PCEDT) and Large (CzEng+PCEDT) Corpus Data}
\label{baselinelargecorpus}

The evaluation set of sentences used in our experiments (see section
\ref{references} below) comes from the very specific domain of Wall Street
Journal. The PCEDT-WSJ section matches this domain exactly, so we
use the PCEDT-WSJ section (20k sentences) as the training data in most of our experiments and refer
to it by the term \equo{baseline corpus} or simply PCEDT. In some
experiments, we make use of all the training data (860k sentences) and refer to it as the
\equo{large corpus}. (Of course, test data
are always excluded from training.)



\begin{table}[t]
\begin{center}
\begin{tabular}{llrrr}
Corpus  &    &  Sentences  &  Tokens\\
\hline
Baseline: PCEDT  &  Czech    &  20,581   &  453,050\\
                 &  English  &  20,581   &  474,336\\
\hline
Large: CzEng+PCEDT     &  Czech    &  862,398  &  10,657,552\\
                 &  English  &  862,398  &  12,001,772\\
\end{tabular}
\end{center}
\caption{Data sizes available for our experiments.}
\label{corpsizes}
\end{table}

Table \ref{corpsizes} reports exact data sizes of the baseline and large
corpora used for our experiments. (Note that the baseline corpus is a subset of
the large corpus.) The data size is significantly lower than what CzEng offers,
because not all of the sentences successfully passed through all our tools and
also due to the removal of sentences longer than 50 words and sentences with the ratio
between Czech and English number of tokens worse than 9.


% Including possible other data (licensing problems):
%File        	Sentences	Tokens
%forbidden.cs	1,030,872	12,339,260
%forbidden.en	1,030,872	13,894,186

%Data: /export/ws06osmt/data/cs-en/training 



\subsubsection{Tuning and Evaluation Data}
\label{references}


Our tuning and evaluation data consist of 515 sentences
with 4 reference
translations. The dataset was first published as part of PCEDT 1.0 for
evaluating \toen{} translation and included original English Wall Street
Journal (WSJ) texts translated to Czech (sentence by sentence) and 4 independent
back-translations to English. For the purposes of \tocs{} translation in our experiments, another 4
independent translations from the original English to Czech were obtained.

For our experiments we kept the original division of the dataset into two parts: the
tuning (development) set and the evaluation test set.
However, we retokenized all the sentences with the Europarl
tokenization tool. Dataset sizes in terms of number of sentences, input tokens
and input tokens never seen in the PCEDT training corpus (out-of-vocabulary,
OOV) are listed in Table \ref{tuneevaldata}.

\begin{table}[ht]
\begin{center}
\begin{tabular}{lccccc}
  &    &  \multicolumn{4}{c}{Input Tokens When Translating from}\\
   &  Sentences   &  Czech  &  OOV   &  English  &  OOV\\
\hline
Tuning   &  259  &  6429  &  6.8\%  &  6675  &  3.5\%\\
Evaluation  &  256  &  5980  &  6.9\%  &  6273  &  3.8\%\\
\end{tabular}
\end{center}
\caption{Tuning and evaluation data.}
\label{tuneevaldata}
\end{table}

We followed the common procedure to use tuning dataset to set parameters of the
translation system and to use the evaluation dataset for final translation
quality estimate. In other words, the translation system has access to the
reference translations of the tuning dataset but never has access to the
reference translations of the evaluation dataset.

In the following, we use the this short notation: \equo{Dev (std)} denotes
results obtained on the tuning dataset with the model parameters set to the
default, somewhat even distribution. \equo{Dev (opt)} denotes results on the
tuning dataset with the parameters optimized using minimum error rate training
procedure (see section \ref{merttuning}). The \equo{Dev (opt)} results are always overly
optimistic, because MERT had access to the reference translations and tunes the
MT output to get the highest scores possible. \equo{Test
(opt)} denotes results on evaluation set with model parameters as optimized on
the tuning set. The \equo{Test (opt)} results thus estimate the system
performance on unseen data and allow for a fair comparison.

For the purposes of automatic translation, the input texts were analyzed using
the same tools as listed in section \ref{tools}.



\subsection{MT Quality Metric and Known Baselines}
\label{baselines}

Throughout all our experiments, we use the BLEU metric \parcite{papineni:2002}
to automatically assess the quality of translation. We use an implementation of
this metric provided for the workshop. Other implementations such as IBM
original or NIST official {\tt mt\_eval} might give slightly
different absolute results, mainly due to different tokenization rules.

In all experiments reported below, we train and test the system in
\emph{case-insensitive} fashion (all data are converted to lowercase, including
the reference translations), except where stated otherwise.



\subsubsection{Human Cross-Evaluation}

Table \ref{crosseval} displays the scores if we evaluate one human translation
against 4 other human translations. For the sake of completeness, we report not
only the default lowercase (LC) evaluation but also case sensitive (CSens)
evaluation. This estimate cannot be understood as any kind of a bound or limit
on MT output scores, but it nevertheless gives some vague orientation when
reading BLEU figures.

\begin{table}[ht]
\begin{center}
\begin{tabular}{llccc|ccc}
   &     &  \multicolumn{3}{c}{To Czech}   &  \multicolumn{3}{c}{To English}\\
  &    &  Min  &  Average  &  Max  &  Min  &  Average  &  Max\\
\hline
Evaluation   &  LC   &  38.5  &  43.1$\pm$4.0  &  48.4   &  41.6  &  54.5$\pm$8.4  &  62.9\\
   &  CSens  &  38.1  &  42.5$\pm$4.0  &  47.8   &  41.1  &  53.8$\pm$8.4  &  62.4\\
\hline
Tuning   &  LC   &  39.0  &  46.3$\pm$4.3  &  49.3   &  45.8  &  55.3$\pm$6.0  &  61.7\\
   &  CSens  &  38.3  &  45.8$\pm$4.4  &  48.8   &  45.0  &  54.7$\pm$6.1  &  61.3\\
\end{tabular}
\end{center}
\caption{BLEU scores of human translation against 4 different human
translations. Evaluated 5 times, always comparing one translation against the 4
remaining. The minimum, average and maximum scores of the 5-fold estimation are
given.}
\label{crosseval}
\end{table}

As expected, we observe a higher variance (standard deviation) when evaluating
translation to English. The reason is that one of the five English versions of
the sentences is the original, while the other four were back translated
from Czech. It is therefore quite likely for the four back translations to differ
more from the original than from each other raising the BLEU variance.

English scores are generally higher and this may indicate that there is less variance
in word order, lexical selection or word morphology in English, but it also
could be the simple case that the translators to English produced more rigid
translations.


\subsubsection{BLEU When not Translating at All}

Our particular type of text (WSJ) contains a lot of numbers and proper names
that are often not altered during translation. Just for curiosity and to 
check that our datasets are not just numbers, punctuation and company names, we
evaluate BLEU for texts not translated at all. I.e. the input text is evaluated
against the standard 4 references. As displayed in Table
\ref{nontransl}, the scores are very low but nonzero, as expected.

\begin{table}[ht]
\begin{center}
\begin{tabular}{llcc}
   &     &  To Czech   &  To English\\
\hline
Evaluation   &  Lowercase   &  2.20  &  2.66\\
Evaluation   &  Case Sensitive   &  2.20  &  2.65\\
Tuning   &  Lowercase   &  2.93  &  3.60\\
Tuning   &  Case Sensitive   &  2.93  &  3.59\\
\end{tabular}
\end{center}
\caption{BLEU scores when not translating at all, i.e. only punctuation, numbers
and some proper names score.}
\label{nontransl}
\end{table}


\subsubsection{Previous Research Results}

Table \ref{comparison} summarizes previously published results of \toen{}
translation. Dependency-based MT (DBMT, \perscite{cmejrek:curin:havelka:2003})
is a system with rule-based transfer from Czech deep syntactic trees (obtained
automatically using one of two parsers of Czech) to English
syntactic trees. GIZA++ \parcite{och:ney:2003} and ReWrite
\parcite{rewrite:germann:2003} is the \equo{standard
baseline} word-based statistical system.
PBT \parcite{zens:etal:pbt:2005} is a phrase-based statistical
MT system developed at RWTH Aachen that has been evaluated on English-Czech data
by \perscite{bojar:etal:fintal:2006}.


\begin{table}[ht]
\begin{center}
\begin{tabular}{l@{\quad}c@{\quad}c@{\quad}|@{\quad}c@{\quad}c}
  &  \multicolumn{2}{@{\hspace{-1em}}c@{\quad}|@{\quad}}{Average over 5 refs.}  &  \multicolumn{2}{@{\quad}c}{4 refs. only}\\
%  &  \multicolumn{2}{c@{\quad}|@{\quad}}{Average  over four}  &  \multicolumn{2}{@{\quad}c@{\quad}}{Four re-translations}\\
%  &  \multicolumn{2}{c@{\quad}|@{\quad}}{re-translations + original}  &  \multicolumn{2}{@{\quad}c}{only}\\
  &  Dev  &  Test  &  Dev  &  Test\\
\hline
DBMT with parser I, no LM            &    18.57  &     16.34  &  -  &  -\\
DBMT with parser II, no LM           &    19.16  &     17.05  &  -  &  -\\
GIZA++ \& ReWrite, bigger LM         &    22.22  &     20.17  &  -  &  -\\
\hline                                   
PBT, no additional LM                &    38.7\stddev{1.5}  &  34.8\stddev{1.3}  &  36.3  &     32.5\\
PBT, bigger LM                       &    41.3\stddev{1.2}  &  36.4\stddev{1.3}  &  39.7  &     34.2\\
\hline                                                                                    
PBT, more parallel texts, bigger LM  &    42.3\stddev{1.1}  &  38.1\stddev{0.8}  &  41.0  &     36.8\\
\end{tabular}
\end{center}
\caption{Previously published results of \toen{} MT.}
\label{comparison}
\end{table}

All figures in Table \ref{comparison} are based on the same training dataset as
we use: the baseline corpus of PCEDT (20k sentences) and on the same tuning and
evaluation sets. However, the tokenization of the data is slightly different the
we use and also a different implementation of the BLEU metric was used. Our
experience is that a different scoring script can change BLEU results by about 2
points absolute, so these numbers should not be directly compared to our results
reported here.

Unlike \perscite{cmejrek:curin:havelka:2003} who evaluate
four-reference BLEU
five times using the original English text in addition to the 4 available
reference back-translations in a leave-one out procedure, we always report BLEU
estimated on the 4 reference translations only.


To the best of our knowledge, we are the first to evaluate \tocs{} machine
translation quality with automatic measures.




\subsection{Experiments}
\label{experiments}



\subsubsection{Motivation: Margin for Improving Morphology}
\label{margin}

Czech is a Slavonic language with very rich morphology and relatively free word
order. (See e.g. \perscite{bojar:cslp:2004} for more details.) The Czech
morphological system defines 4,000 tags in theory and 2,000 were actually seen
in a big tagged corpus. (For comparison, the English Penn Treebank tagset
contains just about 50 tags.) When translating to Czech, any MT system has to
face the richness and generate output words in appropriate forms.

Table \ref{morphmargin} displays BLEU scores of single-factored translation
\tocs{} using the baseline corpus only. The second line in the table gives the
scores if morphological information was disregarded in the evaluation: the MT
output is lemmatized (word forms replaced with their respective base forms) and evaluated against lemmatized references.

\begin{table}[ht]
\begin{center}
\begin{tabular}{lccc}
%     &  pcedt .t0-0. t0-0 LM0-3-pcedt  &                &            &  \\
  &  Dev (std)  &  Dev (opt)  &  Test (opt)\\
\hline
Regular BLEU, lowercase  &  25.68  &  29.24  &  25.23\\
Lemmatized MT output\\
\quad{}against lemmatized references  &  34.29  &  38.01  &  33.63\\
%margin:  &  8.61  &  8.77  &  8.40\\
\end{tabular}
\end{center}
\caption{Margin in BLEU for improving morphology.}
\label{morphmargin}
\end{table}

We see that more than 8 point BLEU absolute could be achieved if output word
forms were chosen correctly.\footnote{Although not all required word forms may
be available in the training data, we could easily generate output word forms
from lemmas and morphological tags deterministically using a large
target-side-only dictionary.} This observation gives us a strong motivation for
focussing on morphological errors first.



\subsubsection{Obtaining Reliable Word Alignment}

Given the richness of Czech morphological system and quite limited amount of
data in the baseline corpus (20k sentences), our first concern was to obtain
reliable word alignments. Like \perscite{bojar:etal:fintal:2006}, we reduce the
data sparseness by either lemmatizing or stemming Czech tokens and stemming
English tokens. (By stemming we mean truncating each word to at most 4
characters.) The vocabulary size of Czech word forms reduces to a half after
stemming or lemmatization and comes thus very close to the vocabulary size of English
word forms.

Table \ref{alignments} displays BLEU scores on Test (opt) \tocs{} depending on the
preprocessing of corpus for word alignment. The translation process itself was
performed on full word forms (single-factored), with a single trigram language
model collected from the Czech side of the parallel corpus. In all cases, we employed the
grow-diag-final heuristic for symmetrization of two independent GIZA++ runs.


\begin{table}[ht]
\begin{center}
\begin{tabular}{cccc}
\multicolumn{2}{c}{Preprocessing for Alignment}  &  \multicolumn{2}{c}{Parallel Corpus Used}\\
English          &  Czech       &  Baseline (20k sents.)  &  Large (860k sents.)\\
\hline
word forms       &  word forms  &                  25.17  &  -\\
4-char stems  &  lemmas      &                  25.23  &                25.40\\
4-char stems            &  4-char stems       &                  25.82  &                24.99\\
\end{tabular}
\end{center}
\caption{BLEU in \tocs{} translation depending on corpus preprocessing for word
alignment.}
\label{alignments}
\end{table}

The results confirm improvement in translation quality if we address the data
sparseness problem for alignments either by full lemmatization or by simple
stemming.  Surprisingly, using full lemmatization of the Czech side scored worse
than just stemming Czech. This result was confirmed neither on the large
training set, nor by \perscite{bojar:etal:fintal:2006} for \toen{} direction, so
we attribute this effect to random fluctuations in MERT procedure.

We also see nearly no gain or even some loss by increasing the corpus size
from 20k to 860k sentences. (See section \ref{moredata}
below for more details on various ways of using more data.)
This observation can be explained by the very specific
domain of our test set.


\subsubsection{Scenarios of Factored Translation \tocs{}}


\subsubsubsection{Scenarios Used}

We experimented with the following factored translation scenarios:

%\begin{tabular}{c@{\hspace{1cm}}c}
%English  &  Czech\\
%\hline
%\Rnode{elc}{lowercase}  &  \Rnode{clc}{lowercase}\\
%\end{tabular}
%\psset{nodesep=5pt,arrows=->}
%\everypsbox{\scriptstyle}
%\ncLine{elc}{clc}

\piccaptioninside
\piccaption{Single-factored scenario (T).}
\parpic[fr]{%
\PSforPDF{
\begin{tabular}{c@{}c@{\hspace{1cm}}c@{}c@{}c@{\hspace{5mm}}c}
English  &    &    &  Czech\\
\hline
lowercase  &  \Rnode{eAlc}{\strut}  &  \Rnode{cAlc}{}  &  {lowercase}  &  \Rnode{cAlcout}{}  &  +LM\\
morphology  &  \Rnode{eAtag}{\strut}  &  \Rnode{cAlemma}{}  &  {lemma} \Rnode{cAlemmaout}{}\\
  &    &  \Rnode{cAtag}{\strut}  &  morphology  &  \Rnode{cAtagout}{}\\
\end{tabular}
\psset{nodesep=1pt,arrows=->}
\everypsbox{\scriptstyle{}}
\ncLine{eAlc}{cAlc}
}
}

The baseline scenario is single-factored: input (English) lowercase word forms
are directly translated to target (Czech) lowercase forms. A 3-gram language
model (or more models based on various corpora) checks the stream of output word forms.

We call this the \equo{T} (translation) scenario.


\piccaption{Checking morphology (T+C).}
\parpic[fr]{%
\PSforPDF{
\begin{tabular}{c@{}c@{\hspace{1cm}}c@{}c@{}c@{\hspace{5mm}}c}
English  &    &    &  Czech\\
\hline
lowercase  &  \Rnode{eBlc}{\strut}  &  \Rnode{cBlc}{}  &  {lowercase}  &  \Rnode{cBlcout}{}  &  +LM\\
morphology  &  \Rnode{eBtag}{\strut}  &  \Rnode{cBlemma}{}  &  {lemma} \Rnode{cBlemmaout}{}\\
  &    &  \Rnode{cBtag}{\strut}  &  morphology  &  \Rnode{cBtagout}{}  &  +LM\\
\end{tabular}
\psset{nodesep=1pt,arrows=->}
\everypsbox{\scriptstyle{}}
\ncLine{eBlc}{cBlc}
\ncbar{->}{cBlcout}{cBtagout}
}
}


In order to check the output not only for word-level coherence but also
for morphological coherence, we add a single generation step: input word forms
are first translated to output word forms and each output word form then
generates its morphological tag.

Two types of language models can be used simultaneously: a (3-gram) LM over word forms and a
LM over morphological tags. For the morphological tags, a higher-order LM can be
used, such as 7 or 9-gram.

We used tags with various levels of detail, see section \ref{posgranularity}.
We call this the \equo{T+C} (translate and check) scenario.


\piccaption{Translating and checking morphology (T+T+C).}
\parpic[fr]{
\PSforPDF{
\begin{tabular}{c@{}c@{\hspace{1cm}}c@{}c@{}c@{\hspace{5mm}}c}
English  &    &    &  Czech\\
\hline
lowercase  &  \Rnode{eClc}{\strut}  &  \Rnode{cClc}{}  &  {lowercase}  &  \Rnode{cClcout}{}  &  +LM\\
morphology  &  \Rnode{eCtag}{\strut}  &  \Rnode{cClemma}{}  &  {lemma} \Rnode{cClemmaout}{}\\
  &    &  \Rnode{cCtag}{\strut}  &  morphology  &  \Rnode{cCtagout}{}  &  +LM\\
\end{tabular}
\psset{nodesep=1pt,arrows=->}
\everypsbox{\scriptstyle{}}
\ncLine{eClc}{cClc}
\ncLine{eCtag}{cCtag}
\ncbar{->}{cClcout}{cCtagout}
}
}

As a refinement of T+C, we also used T+T+C scenario, where the morphological
output stream is constructed based on both, output word forms and input
morphology. This setting should ensure correct translation of morphological
features such as number of source noun phrases.
%, while the T+C setting simply guessed number of noun
%phrases based on the language models.

Again, two types of language models can be used in this \equo{T+T+C} scenario.

\piccaption{Generating forms from lemmas and tags (T+T+G).}
\parpic[fr]{%
\PSforPDF{
\begin{tabular}{c@{}c@{\hspace{1cm}}c@{}c@{}c@{\hspace{5mm}}c}
English  &    &    &  Czech\\
\hline
lowercase  &  \Rnode{e2lc}{\strut}  &  \Rnode{c2lc}{}  &  {lowercase}  &  \Rnode{c2lcout}{}  &  +LM\\
morphology  &  \Rnode{e2tag}{\strut}  &  \Rnode{c2lemma}{}  &  {lemma} \Rnode{c2lemmaout}{}  &    &  +LM\\
  &    &  \Rnode{c2tag}{\strut}  &  morphology  &  \Rnode{c2tagout}{}  &  +LM\\
\end{tabular}
\psset{nodesep=1pt,arrows=->}
\everypsbox{\scriptstyle{}}
\ncLine{e2tag}{c2tag}
\ncLine{e2lc}{c2lemma}
\ncbar{->}{c2lemmaout}{c2lcout}
\ncbar{->}{c2tagout}{c2lcout}
}
}

The most complex scenario we used is linguistically appealing: output lemmas
(base forms) and morphological tags are generated from input in two independent
translation steps and combined in a single generation step to produce
output word forms. The input English text was not lemmatized so we used English
word forms as the source for producing Czech lemmas.

The \equo{T+T+G} setting allows us to use up to three types of language models.
Trigram models are used for word forms and lemmas and 7 or 9-gram language
models are used over tags.



%% small pictures
%\psset{unit=5mm}
%\begin{pspicture}(0,-0.5)(3,0.5)
%\psline{->}(0,0)(3,0)
%\pscircle*[fillcolor=white](0,0){0.5ex}
%\end{pspicture}
%
%\psset{unit=5mm}
%\begin{pspicture}(0,-0.5)(3,1.5)
%\psline{->}(0,1)(3,1)
%\psline{->}(3,1)(3,0)
%\end{pspicture}
%
%\psset{unit=5mm}
%\begin{pspicture}(0,-0.5)(3,2.5)
%\psline{->}(0,2)(3,2)
%\psline{->}(0,1)(3,0)
%\psline{->}(3,2)(3,0)
%\end{pspicture}
%
%
%\psset{unit=5mm}
%\begin{pspicture}(0,-0.5)(3,2.5)
%\psline{->}(0,2)(3,1)
%\psline{->}(0,1)(3,0)
%\psline{->}(3,1)(3.5,1)(3.5,2)(3,2)
%\psline{->}(3,0)(3.5,0)(3.5,2)(3,2)
%\end{pspicture}



\subsubsubsection{Experimental Results: T+C Works Best}

Table \ref{scenariosresults} summarizes estimated translation quality of the
various scenarios. In all experiments, only the baseline corpus of 20k sentences
was used with word alignment obtained using grow-diag-final heuristic on stemmed
English and lemmatized Czech input streams. Language models are also based
on the 20k sentences only, 3-grams are used for word forms and lemmas, 7-grams
for morphological tags.


\begin{table}[ht]
\begin{center}
\begin{tabular}{lccc}
  &  Dev (std)  &  Dev (opt)  &  Test (opt)\\
\hline
Baseline: T      &  25.68  &  29.24  &  25.23\\
T+T+G  &  23.93  &  30.34  &  25.94\\
T+T+C  &  25.12  &  30.73  &  26.43\\
T+C    &  23.51  &  \max{30.88}  &  \max{27.23}\\
\end{tabular}
\end{center}
\caption{BLEU scores of various translation scenarios.}
\label{scenariosresults}
\end{table}

The good news is that multi-factored models always outperform the baseline T
(except for \equo{Dev (std)}, but this is not surprising, as the default weights
can be quite bad for multi-factored translation).

Unfortunately, the more complex a multi-factored scenario is, the worse
the results are. Our belief is that this effect is caused by search errors: with
multi-factored models, more hypotheses get similar scores and future costs
of partial hypotheses might be estimated less reliably. With the limited stack
size (not more than 200 hypotheses of the same number of covered input words),
the decoder may more often find sub-optimal solutions.

To conclude, the scenario for just checking output morphology (T+C) gives us the
best results, 27.23 BLEU, 2 points absolute improvement over the single-factored
baseline.



\subsubsection{Granularity of Czech Part-of-Speech}
\label{posgranularity}


As stated above, Czech morphological tag system is very complex, in theory up to
4,000 different tags are possible. In our T+C scenario, we experiment with
various simplifications of the system to find the best balance between
expresivity and richness of the statistics available in our corpus. (The more
information is retained in the tags, the more severe data sparseness is.)

% Details in morftaginfo/*.info
%pcedt.cs.2.info	1                  	1098  	453050	412.61
%pcedt.cs.cng02.info	1                  	707   	453050	640.81
%pcedt.cs.cng03.info	1                  	899   	453050	503.95
%pcedt.cs.cng.info	1                  	571   	453050	793.43
%pcedt.cs.pos.info	1                  	173   	453050	2618.79


\begin{description}

\item[Full tags (1098 unique seen in baseline corpus):]
Full Czech positional tags are used. A tag consists of 15
positions, each holding the value of a morphological property (e.g. number, case
or gender).


\item[POS (173 unique seen):]
We simplify the tag to include only part and subpart of speech (distinguishes
also partially e.g. verb tenses). For nouns, pronouns, adjectives and
prepositions\footnotemark{}, also the case is included.\footnotetext{Some Czech prepositions select
for a particular case, some are ambiguous. Although the case is never shown on
surface of the preposition, the tagset includes this information and Czech
taggers are able to infer the case.}


\item[CNG01 (571 unique seen):]
CNG01 refines POS. For nouns, pronouns and adjectives we include not only the
case but also number and gender.


\item[CNG02 (707 unique seen):]
Tag for punctuation is refined: lemma of the punctuation symbol is taken into
  account; previous models disregarded e.g. the distributional differences between a comma and a
  question mark.
Case, number and gender added to nouns, pronouns, adjectives, prepositions,
  but also to verbs and numerals (where applicable).


\item[CNG03 (899 unique seen):]
Highly optimized tagset:
\begin{itemize}

\item Tags for nouns, adjectives, pronouns and numerals describe the case, number
  and gender; the Czech reflexive pronoun \text{se} or \text{si} is highlighted
  by a special flag.

\item Tag for verbs describes subpart of speech, number, gender, tense and
  aspect; the tag includes a special flag if the verb was the auxiliary verb
  \text{b\'{y}t (to be)} in any of its forms.

\item Tag for prepositions includes the case and also the lemma of the preposition.

\item Lemma included for punctuation, particles and interjections.

\item Tag for numbers describes the \equo{shape} of the number (all digits are
  replaced by the digit \text{5} but number-internal punctuation is kept
  intact). The tag thus distinguishes between 4- or 5-digit numbers or the
  precision of floating point numbers.

\item Part of speech and subpart of speech for all other words.
\end{itemize}

\end{description}


\subsubsubsection{Experimental Results: CNG03 Best}

Table \ref{granularityresults} summarizes the results of T+C scenario with
varying detail in morphological tag. All the results were obtained using only
the baseline corpus of 20k sentences, word-alignment symmetrized with
grow-diag-final heuristic and based on stemmed Czech and English input. Also the
language models are based solely on the 20k sentences. Trigrams are used for
word forms and 7-grams for tags.

\begin{table}[ht]
\begin{center}
\begin{tabular}{lccc}
  &  Dev (std)  &  Dev (opt)  &  Test (opt)\\
\hline
Baseline: T (single-factor)  &  26.52        &  28.77        &  25.82\\
T+C, CNG01     &  22.30         &  29.86        &  26.14\\
T+C, POS       &  21.77         &  30.27        &  26.57\\
T+C, full tags       &  22.56         &  29.65        &  27.04\\
T+C, CNG02     &  23.17         &  \max{30.77}        &  27.45\\
T+C, CNG03     &  23.27         &  30.75        &  \max{27.62}\\
\end{tabular}
\end{center}
\caption{BLEU scores of various granularities of morphological tags in T+C
scenario.}
\label{granularityresults}
\end{table}


Our results confirm significant improvement over single-factored baseline.
Detailed knowledge of the morphological systems also proves its utility: by
choosing the most relevant features of tags and lemmas but avoiding sparseness,
we can improve about 0.5 BLEU absolute over T+C with full tags. Too strict
reduction of features used causes a loss.



\subsubsection{More Out-of-Domain Data in T and T+C Scenarios}
\label{moredata}


%                                                           	BLEU.dev.opt	BLEU.dev.std	BLEU.opt	Class	Data
%czeng LM0-3-czeng t0-0                                     	       28.74	       23.47	   24.99	1	mixed
%pcedt LM0-3-pcedt t0-0                                     	       28.77	       26.52	   25.82	1	small
%czeng LM0-3-czeng LM1-7-czeng tag                          	       29.50	       15.66	   26.54	2	mixed
%pcedt LM0-3-pcedt LM1-7-pcedt tag                          	       29.65	       22.56	   27.04	2	small
%pcedt LM0-3-pcedt LM0-3-czeng LM1-7-pcedt LM1-7-czeng tag  	       30.33	       19.97	   27.15	2	separate
%pcedt LM0-3-pcedt LM0-3-czeng LM1-7-pcedt LM1-7-czeng cng03	       30.48	       19.95	   27.15	3	separate
%czeng LM0-3-czeng LM1-7-czeng cng03                        	       30.71	       15.77	   27.29	3	mixed
%czeng LM0-3-czeng LM0-3-pcedt t0-0                         	       29.42	       19.45	   27.41	1	separate
%czeng LM0-3-pcedt LM0-3-czeng LM1-7-pcedt LM1-7-czeng cng03	       30.33	       14.22	   27.48	3	separate
%pcedt LM0-3-pcedt LM1-7-pcedt cng03                        	       30.75	       23.27	   27.62	3	small
%czeng LM0-3-pcedt LM0-3-czeng LM1-7-pcedt LM1-7-czeng tag  	       30.64	       14.06	   28.12	2	separate

% definice trid:
% 1  ... t0-0
% 2  ... P+K tag
% 3  ... P+K cng03
% 4  ... P

%   !dett | sed 's/\%//' | tabrecalc '\qdisk(COL4,COL5){3pt}  \uput[ur](COL4,COL5){COL4 COL6}'


\begin{figure}[t]
\begin{center}
\PSforPDF{
\psset{xunit=25mm,yunit=10mm}
\begin{pspicture*}(23.5,-0.7)(28.5,3)
%\psgrid

\qdisk(24.99,0.5){2pt}  \uput[u](24.99,0.5){mix}
\qdisk(25.82,0.5){2pt}  \uput[u](25.82,0.5){s}
\qdisk(26.54,1.5){2pt}  \uput[u](26.54,1.5){mix}
\qdisk(27.04,1.5){2pt}  \uput[d](27.04,1.5){s}
\qdisk(27.15,1.5){2pt}  \uput[ur](27.15,1.5){s$^+$}
\qdisk(27.15,2.5){2pt}  \uput[u](27.15,2.5){s$^+$}
\qdisk(27.29,2.5){2pt}  \uput[d](27.29,2.5){mix}
\qdisk(27.41,0.5){2pt}  \uput[u](27.41,0.5){L}
\qdisk(27.48,2.5){2pt}  \uput[u](27.48,2.5){L}
\qdisk(27.62,2.5){2pt}  \uput[d](27.62,2.5){s}
\qdisk(28.12,1.5){2pt}  \uput[u](28.12,1.5){L}

\psline(23,1)(29,1)
\psline(23,2)(29,2)

\rput[l](23.5,0.5){T}
\rput[l](23.5,1.5){T+C full tags}
\rput[l](23.5,2.5){T+C CNG03}

\psaxes[Ox=23,Dx=1,Dy=5](23,0)(29,3)
\end{pspicture*}
}
\end{center}

\begin{center}
\small
\begin{tabular}{cp{0.85\textwidth}}
s  &  small data, 20k sentences in the domain\\
s$^+$  &  small data, 20k sentences in the domain with an additional separate LM (860k sents out of the domain)\\
L  &  large data, 860k sentences, separate in-domain and out-of-domain LMs\\
mix  &  large data, 860k sentences, a single LM mixes the domains\\
\end{tabular}
\end{center}
%\begin{center}
\footnotesize
\hspace{-10mm}
\begin{tabular}{lcccrrr}
Scenario  &  Acronym  &  Parallel Corpus  &  Language Models  &  Dev (std)  &  Dev (opt)  &  Test (opt)\\
\hline
T              &  mix    &  Large (860k)    &  Large (860k)    &  23.47  &  28.74  &        24.99\\
T              &  s      &  Baseline (20k)  &  Baseline (20k)  &  26.52  &  28.77  &        25.82\\
T+C full tags  &  mix    &  Large (860k)    &  Large (860k)    &  15.66  &  29.50  &        26.54\\
T+C full tags  &  s      &  Baseline (20k)  &  Baseline (20k)  &  22.56  &  29.65  &        27.04\\
T+C full tags  &  s$^+$  &  Baseline (20k)  &  20k+860k        &  19.97  &  30.33  &        27.15\\
T+C CNG03      &  s$^+$  &  Baseline (20k)  &  20k+860k        &  19.95  &  30.48  &        27.15\\
T+C CNG03      &  mix    &  Large (860k)    &  Large (860k)    &  15.77  &  30.71  &        27.29\\
T              &  L      &  Large (860k)    &  20k+860k        &  19.45  &  29.42  &        27.41\\
T+C CNG03      &  L      &  Large (860k)    &  20k+860k        &  14.22  &  30.33  &        27.48\\
T+C CNG03      &  s      &  Baseline (20k)  &  Baseline (20k)  &  23.27  &  30.75  &        27.62\\
T+C full tags  &  L      &  Large (860k)    &  20k+860k        &  14.06  &  30.64  &  \max{28.12}\\
\end{tabular}
%\end{center}
\caption{The effect of additional data in T and T+C scenarios.}
\label{moredatachart}
\end{figure}


Figure \ref{moredatachart} gives a chart and full details on our experiments
with adding more data into the T and T+C scenarios. We varied the scenario (T or
T+C), the level of detail in the T+C scenario (full tags vs. CNG03), the size of the
parallel corpus used to extract phrases (Baseline vs. Large, as described in
section \ref{baselinelargecorpus}) and the size or combination of target side language models (a
single LM based on the Baseline or Large corpus, or both of them with separate
weights set in the MERT training).

Several observations can be made:

\begin{itemize}

\item Ignoring the domain difference and using only the single Large language model
  (denoted \equo{mix} in the chart) hurts. Only the \equo{T+C CNG03} scenario
  does not confirm this observation and we believe this can be attributed to
  some randomness in MERT training of \equo{T+C CNG03 s$^+$}.

\item CNG03 outperforms full tags only in small data setting, with large data
  (treating the domain difference properly), full tags are significantly better.

\item The improvement of T+C over T decreases if we use more data.
\end{itemize}




\subsubsection{First Experiments with Verb Frames}



\subsubsubsection{Microstudy: Current MT Errors}
\label{microstudy}

The previous sections described significant improvements gained on small data
sets when checking morphological agreement or adding more data (BLEU raised from
25.82\% to 27.62\% or up to 28.12\% with additional out-of-domain parallel
data). However, the best result achieved is still far below the margin of
lemmatized BLEU, as estimated in section \ref{margin}. In fact, lemmatized BLEU
of our best result is yet a bit higher (35\%), indicating that T+C 
improve not only morphology, but also word order or lexical selection issues.

We performed a microstudy on local agreement between adjectives and their
governing nouns. Altogether 74\% of adjectives agreed with the governing noun
and only 2\% of adjectives did not agree; the full listing is given in Table
\ref{agreement}.

\begin{table}[t]
\begin{center}
\begin{tabular}{lr}
\bf An adjective in MT output\dots  &  \llap{\bf Portion}\\
\hline
\bf agrees with the governing noun  &  \bf 74\%\\
depends on a verb (cannot check the agreement)  &  7\%\\
misses the governing noun (cannot check the agreement)  &  7\%\\
should not occur in MT output  &  5\%\\
has the governing noun not translated (cannot check the agreement)  &  5\%\\
\bf mismatches with the governing noun  &  \bf 2\%\\
\end{tabular}
\end{center}
\caption{Microstudy: adjectives in \tocs{} MT output.}
\label{agreement}
\end{table}


Local agreement thus seems to be relatively correct. In order to find the source
of the remaining morphological errors, we performed another microstudy of
current best MT output (BLEU 28.12\%) using an intuitive metric. We checked
whether Verb-Modifier relations are properly preserved during the translation of
15 sample sentences.


%Verb:   
%ok      43 (55.8 %)
%miss    21 (27.3 %)
%bad     11 (14.3 %)
%semi    2 (2.6 %)
%Celkem  77 (100.0 %)
%
%Noun    
%ok      61 (79.2 %)
%bad     9 (11.7 %)
%unk     4 (5.2 %)
%semi    2 (2.6 %)
%miss    1 (1.3 %)
%Celkem  77 (100.0 %)


The \emph{source} text of the sample sentences contained 77
Verb-Modifier pairs. Table \ref{verbmod} lists our observations on the two
members in each Verb-Modifier pair. We see that only 43\% of verbs are
translated correctly and 79\% of nouns are translated correctly. The system
tends to skip verbs quite often (21\% of cases).

\begin{table}[t]
\begin{center}
\begin{tabular}{lcc}
\bf Translation of            &  \bf Verb  &  \bf Modifier\\
\hline
\dots{}preserves meaning  &  56\%  &  79\%\\
\dots{}is disrupted       &  14\%  &  12\%\\
\dots{}is missing         &  27\%  &  1\%\\
\dots{}is unknown (not translated)         &  0\%   &  5\%\\
\end{tabular}
\end{center}
\caption{Analysis of 77 Verb-Modifier pairs in 15 sample sentences.}
\label{verbmod}
\end{table}


More
importantly, our analysis has shown that even in cases where both the Verb and
the Modifier are correct, the relation between them in Czech is either
non-gramatical or meaning-disturbing in 56\% of these cases. Commented samples
of such errors are given in Figure \ref{sampleerrors}. The first sample shows
that a strong language model can lead to the choice of a grammatical relation
that nevertheless does not convey the original meaning. The second sample
illustrates a situation where two correct options are available but the
system chooses an inappropriate relation, most probably because of backing off to
a generic pattern verb-noun$_{plural}^{accusative}$. This pattern
is quite common for
for expressing the object role of
many verbs (such as \text{vydat}, see Correct
option 2 in Figure \ref{sampleerrors}), but does not fit well with the verb
\text{vyb\v{e}hnout}. While the target-side data
may be rich enough to learn the generalization vyb\v{e}hnout--s--{\it instr},
no
such generalization is possible with language models over word forms or
morphological tags only. The
target side data will be hardly ever rich enough to learn this particular
structure in all correct morphological and lexical variants:
\text{vyb\v{e}hl--s--reklamou, vyb\v{e}hla--s--reklamami,
vyb\v{e}hl--s--prohl\'{a}\v{s}en\'{\i}m, vyb\v{e}hli--s--ozn\'{a}men\'{\i}m,
\dots}. We would need a 
mixed
model that combines verb lemmas, prepositions and case information to properly
capture the relations.


\begin{figure}

\begin{center}
{\small
\begin{tabular}{|ll|}
\hline
Input:      &  {Keep on investing.}\\
MT output:  &  Pokra\v{c}ovalo investov\'{a}n\'{\i}. (grammar correct here!)\\
Gloss:      &  Continued investing. (Meaning: The investing continued.)\\
Correct:    &  {Pokra\v{c}ujte v investov\'{a}n\'{\i}.}\\
\hline
\end{tabular}
}
\end{center}


\begin{center}
{
\small
\begin{tabular}{|lllll|}
\hline
Input:  &  \multicolumn{4}{l|}{brokerage firms rushed out ads \dots}\\
MT Output:  &  brokersk\'{e}  &  firmy  &  vyb\v{e}hl  &  reklamy\\
Gloss:  &  brokerage  &  firms$_{pl.fem}$  &  ran$_{sg.masc}$  &  ads$_{pl.nom,pl.acc}^{pl.voc,sg.gen}$\\
Correct option 1:  &  brokersk\'{e}  &  firmy  &  vyb\v{e}hly  &  s reklamami$_{pl.instr}$\\
Correct option 2:  &  brokersk\'{e}  &  firmy  &  vydaly  &  reklamy$_{pl.acc}$\\
\hline
\end{tabular}
}
\end{center}
\caption{Two sample errors in translating Verb-Modifier relation from English to
Czech.}
\label{sampleerrors}
\end{figure}







To sum up, the analysis has revealed that in our best MT output:

\begin{itemize}

\item noun-adjective agreement is already quite fine,

\item verbs are often missing,

\item verb-modifier relations are often malformed.
\end{itemize}


\subsubsubsection{Design of Verb Frame Factor}


In this section we describe a model that combines verb lemmas, prepositions and
noun cases to improve the verb-modifier relations on the target side and
possibly to favour keeping verbs in MT output. The model
is incorporated to our MT system in the most simple fashion: we simply create an
additional output factor to explicitly model target verb
valency/subcategorization, i.e. to mark verbs and their modifiers in the output.
An independent language model is used to ensure coherence in the verb frame
factor.

Figure \ref{samplevf} illustrates the process of converting a Czech sentence to
the corresponding verb frame factor. We make use of the dependency analysis of
the sentence and associate each input word with a token:

\begin{itemize}

\item tokens for verbs have the form \text{H:V\ang{subpart of speech}:\ang{verb
  lemma}} indicating that the verb is the head of the frame,

\item tokens for words depending on a verb have the form \text{M:\ang{slot
  description}} to denote verb frame members. Slot description is based on the
  respective modifier:
\begin{itemize}

\item slot description for nouns, pronouns and (nominalized) adjectives contains
  only the case information (e.g. \text{subst$_{nom}$} for nouns or pronouns in
  nominative),

\item slot description for prepositions contains the preposition lemma and the
  case (e.g. \text{prep:na$_{acc}$} for the preposition \text{na} in accusative),

\item sub-ordinating conjunctions are represented by their lemma (e.g.
  \text{subord:zda} for the conjunction \text{zda}),

\item co-ordinating conjunctions are treated in an oversimplified manner, the slot
  description just notes that there was a co-ordinating conjunction. No
  information is propagated from the co-ordinated elements.

\item adverbs are completely ignored, i.e. get a dummy token \text{---}
\end{itemize}

\item punctuation symbols have the form \text{PUNCT:\ang{punctuation symbol}} and
  conjunctions have the form \text{DELIM:\ang{subpart of
  speech}:\ang{conjunction lemma}} to
  keep track of structural delimiters in the verb frame factor,

\item all other words get a dummy token \text{---}.
\end{itemize}

Thus for the beginning of the sample sentence in Figure \ref{samplevf}
\text{Popt\'{a}vka trvale stoup\'{a} za podpory\dots (The demand has been consistently
growing under the encouragement\dots)} we create the following stream:

\begin{center}
M:subst$_{nom}$ --- H:VB:stoupat M:prep:za$_{gen}$ ---
\end{center}

The stream indicates that the verb \text{stoupat} tends to be modified by a
(preceding) subject and (following) argument or adjunct governed by the
preposition \text{za} in genitive.

Keeping in mind the valency theory for Czech (e.g. \perscite{panevova:94}),
there are several limitations in our model:

\begin{itemize}

\item We do not make any distinctions between
argument and adjuncts (except for the above mentioned deletion of adverbs).
Ideally, all adjuncts would get the dummy token \text{---}.


\item In theory,
the order of verb frame members is not grammatically significant for some
languages, so we should allow independent reordering of the verb frame factor.


\item If a verb depends on a verb, their modifiers can be nearly arbitrarily mixed
  within the clause (in Czech). Our model does not distinguish which modifiers
  belong to which of the verbs.

\end{itemize}

Another problem with the verb frame factor is the explicit representation of
the number of intervening words (tokens \text{---}). A skipping language model
would be necessary to describe the linguistic reality more adequately.


%<s id="wsj-underscore-1200.cz:3">
%<f>Popt\'{a}vka<MDl src="a">popt\'{a}vka<MDt src="a">NNFS1-----A----<A>Sb<r>1<g>3
%<f>trvale<MDl src="a">trvale-underscore--caret--underscore-*1\'{y}-underscore-<MDt src="a">Dg-------1A----<A>Adv<r>2<g>3
%<f>stoup\'{a}<MDl src="a">stoupat-underscore-:T<MDt src="a">VB-S---3P-AA---<A>Obj<r>3<g>9
%<f>za<MDl src="a">za-1<MDt src="a">RR--2----------<A>AuxP<r>4<g>3
%<f>podpory<MDl src="a">podpora-underscore--caret--underscore-pen\'{\i}ze;-underscore-ty\v{c};-underscore-mor\'{a}ln\'{\i}-underscore-p.-underscore-<MDt src="a">NNFS2-----A----<A>Adv<r>5<g>4
%<f>vl\'{a}dn\'{\i}<MDl src="a">vl\'{a}dn\'{\i}<MDt src="a">AAFS2----1A----<A>Atr<r>6<g>7
%<f>politiky<MDl src="a">politika-underscore--caret--underscore-v\v{e}da-underscore-<MDt src="a">NNFS2-----A----<A>Atr<r>7<g>5
%<f>,<MDl src="a">,<MDt src="a">Z:-------------<A>AuxX<r>8<g>3
%<f>\v{r}ekl<MDl src="a">\v{r}\'{\i}ci<MDt src="a">VpYS---XR-AA---<A>Pred<r>9<g>0
%<f>mluv\v{c}\'{\i}<MDl src="a">mluv\v{c}\'{\i}<MDt src="a">NNMS1-----A----<A>Sb<r>10<g>9

%popt\'{a}vka trvale stoup\'{a} za podpory prospot\v{r}ebitelsk\'{e} vl\'{a}dn\'{\i} politiky , \v{r}ekl mluv\v{c}\'{\i} asociace .
%MEMBER:subst+1 --- HEAD:VB:stoupat_:T MEMBER:Rza-1+2 --- --- --- --- MEMBER:Z- HEAD:Vp:\v{r}\'{\i}ci MEMBER:subst+1 --- PUNCT:.

%<f>\broken{Popt\'{a}vka\\MEMBER:subst+1}<A>Sb<r>1<g>3
%<f>\broken{trvale\\---}<A>Adv<r>2<g>3
%<f>\broken{stoup\'{a}\\HEAD:VB:stoupat\_:T}<A>Obj<r>3<g>9
%<f>\broken{za\\MEMBER:Rza-1+2}<A>AuxP<r>4<g>3
%<f>\broken{podpory\\---}<A>Adv<r>5<g>4
%<f>\broken{vl\'{a}dn\'{\i}\\---}<A>Atr<r>6<g>7
%<f>\broken{politiky\\---}<A>Atr<r>7<g>5
%<f>\broken{,\\MEMBER:Z-}<A>AuxX<r>8<g>3
%<f>\broken{\v{r}ekl\\HEAD:Vp:\v{r}\'{\i}ci}<A>Pred<r>9<g>0
%<f>\broken{mluv\v{c}\'{\i}\\MEMBER:subst+1}<A>Sb<r>10<g>9
%<f>\broken{.\\PUNCT:.}<A>AuxK<r>11<g>0

\begin{figure}[ht]
\PSforPDF{
\def\ctr#1{\hbox to \wd0{\hss{}\hbox{\strut{}#1}\hss{}}}
\def\ctrclap#1{\hbox to \wd0{\hss{}\strut\clap{#1}\hss{}}}
\def\brok#1#2#3#4{{\setbox0=\hbox{#1}\vbox{\ctr{#1}\ctrclap{#3}\ctr{#4}\ctr{\scriptsize #2}}}}

\begin{idtree}
\node{1}{3}{\vbox{\brok{Popt\'{a}vka}{Demand}{}{M:subst$_{nom}$}}}
\node{2}{3}{\brok{trvale}{consistently}{}{---}{}}
\node{3}{2}{\brok{stoup\'{a}}{grows}{H:VB:stoupat}{}}
\node{4}{3}{\brok{za}{\lower0.4ex\hbox{under}}{}{M:prep:za$_{gen}$}}
\node{5}{4}{\brok{podpory}{\raise1mm\hbox{encouragement}}{---}{}}
\node{6}{6}{\brok{vl\'{a}dn\'{\i}}{\lower0.4ex\hbox{government}}{---}{}}
\node{7}{5}{\brok{politiky}{policies}{---}{}}
\node{8}{3}{\brok{,}{,}{}{M:Z-}}
\node{9}{1}{\brok{\v{r}ekl}{said}{H:Vp:\v{r}\'{\i}ci}{}}
\node{10}{2}{\brok{mluv\v{c}\'{\i}}{spokesman}{}{M:subst$_{nom}$}}
\node{11}{1}{\brok{.}{.}{PUNCT:.}{}}
\edge{3}{1}{Sb  }
\edge{3}{2}{Adv}
\edge{9}{3}{Obj}
\edge{3}{4}{AuxP}
\edge{4}{5}{Adv}
\edge{7}{6}{Atr}
\edge{5}{7}{Atr}
\edge{3}{8}{AuxX}
\edge{9}{10}{Sb}
\end{idtree}
}
\caption{Verb frame factor based on dependency syntax tree of a sample sentence:
\text{
Demand has been growing consistently under the encouragement of government policies, a spokesman said.
}}
\label{samplevf}
\end{figure}

%Popt\'{a}vka   	Sb  	 1	3	popt\'{a}vka	MEMBER:subst+1
%trvale         	Adv 	 2	3	trvale  	---
%stoup\'{a}     	Obj 	 3	9	stoup\'{a}  	HEAD:VB:stoupat\_:T
%za             	AuxP	 4	3	za      	MEMBER:Rza-1+2
%podpory        	Adv 	 5	4	podpory 	---
%vl\'{a}dn\'{\i}	Atr 	 6	7	vl\'{a}dn\'{\i}  	---
%politiky       	Atr 	 7	5	politiky	---
%,              	AuxX	 8	3	,       	MEMBER:Z-
%\v{r}ekl       	Pred	 9	0	\v{r}ekl    	HEAD:Vp:\v{r}\'{\i}ci
%mluv\v{c}\'{\i}	Sb  	10	9	mluv\v{c}\'{\i}  	MEMBER:subst+1
%.              	AuxK	11	0	.       	PUNCT:.

%<s id="wsj-underscore-1200.mrg:3">
%<f>Demand<l>demand<t>NN<A>Sb<r>1<g>4<x name="Wf">-SBJ<x name="Wl">NP~-SBJ<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/1<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/1
%<f>has<l>have<t>VBZ<A>AuxV<r>2<g>4<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/3<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/2
%<f>been<l>be<t>VBN<A>Atr<r>3<g>4<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/4<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/3
%<f>growing<l>grow<t>VBG<A>Obj<r>4<g>17<x name="Wf">-TPC-1<x name="Wl">S~-TPC-1<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/5<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/4
%<f>consistently<l>consistently<t>RB<A>Adv<r>5<g>4<x name="Wf">-MNR<x name="Wl">ADVP-MNR<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/6<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/5
%<f>under<l>under<t>IN<A>AuxP<r>6<g>4<x name="Wf">-LOC<x name="Wl">PP-LOC<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/8<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/6
%<f>the<l>the<t>DT<A>Atr<r>7<g>8<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/9<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/7
%<f>encouragement<l>encouragement<t>NN<A>Adv<r>8<g>6<x name="Wl">NP~<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/10<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/8
%<f>of<l>of<t>IN<A>AuxP<r>9<g>8<x name="Wl">PP<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/12<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/9
%<f>pro-consumption<l>pro-consumption<t>NN<A>Atr<r>10<g>12<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/13<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/10
%<f>government<l>government<t>NN<A>Atr<r>11<g>12<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/14<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/11
%<f>policies<l>policy<t>NNS<A>Atr<r>12<g>9<x name="Wl">NP~<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/15<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/12
%<D>
%<d>,<l>,<t>,<A>AuxX<r>13<g>17<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/24<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/13
%<f>an<l>an<t>DT<A>Atr<r>14<g>16<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/25<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/14
%<f>association<l>association<t>NN<A>Atr<r>15<g>16<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/26<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/15
%<f>spokesman<l>spokesman<t>NN<A>Sb<r>16<g>17<x name="Wf">-SBJ<x name="Wl">NP~-SBJ<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/27<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/16
%<f>said<l>say<t>VBD<A>Pred<r>17<g>0<x name="Wl">S<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/29<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/17
%<D>
%<d>.<l>.<t>.<A>AuxK<r>18<g>0<x name="wsj-underscore-id">wsj-underscore-1200.mrg:3/35<x name="wsj-underscore-id2">wsj-underscore-1200.mrg:3/18


\subsubsubsection{Preliminary Results with Verb Frame Factor}

Table \ref{vfresults} displays BLEU scores of the scenario translate-and-check verb factor
(T+Cvf) compared to the single-factored baseline (T). Word alignment for these
experiments was obtained using grow-diag-final heuristic on stemmed English and
lemmatized Czech texts. Only the baseline corpus (20k sentences) was used to
extract phrase tables. The verb frame factor language model is a simple $n$-gram
LM with $n$ of 7, 9 or 11 and it is based either on the baseline corpus (PCEDT)
or the Czech side of the Large corpus. In all cases, a simple trigram model
checks the fluency of word form stream.


%VFF: vf LM1-11-czeng	28.68      	19.51       	24.23
%Baseline: t0-0       	29.24*      	25.68>      	25.23>

\begin{table}[ht]
\begin{center}
\begin{tabular}{lccc}
                       &  Dev (std)  &  Dev (opt)  &  Test (opt)\\
\hline
T+Cvf LM-11gr-Large    &         19.51  &       28.68  &        24.23\\
T+Cvf LM-7gr-Baseline  &         19.75  &       28.54  &        25.05\\
T+Cvf LM-7gr-Large     &         19.69  &       28.32  &        25.07\\
T+Cvf LM-9gr-Large     &         19.55  &       27.98  &        25.09\\
Baseline: T            &         25.68  &       29.24  &  \max{25.23}\\
\end{tabular}
\end{center}
\caption{Preliminary results with checking of verb frame factor.}
\label{vfresults}
\end{table}

Unfortunately, all T+Cvf results fall below the single-factored baseline.
Table \ref{vffanalysis} gives some more detail on this result. We performed the
same type of analysis of verb-modifier pairs in the first 15 output sentences,
as described in section \ref{microstudy}. The baseline columns are based on the
single-factored output (BLEU 25.23), the VFF columns are based on T+Cvf
LM-11gr-Large (BLEU 24.23).


\begin{table}[ht]
\begin{center}
\begin{tabular}{lcc|cc}
\bf Translation of  &  \multicolumn{2}{c}{\bf Verb}  &  \multicolumn{2}{c}{\bf Modifier}\\
      &  Baseline  &  VFF  &  Baseline  &  VFF\\
\hline
\dots{}preserves meaning    &     38  &    40  &     57  &    55\\
\dots{}is disrupted   &     17  &    20  &     15  &    15\\
\dots{}is missing  &     15  &    10  &      0  &     1\\
\dots{}is unknown (not translated)   &      7  &     7  &      5  &     6\\
\end{tabular}
\end{center}
\caption{Analysis of 77 Verb-Modifier pairs in baseline output and in
verb-frame-factor (VFF) output.}
\label{vffanalysis}
\end{table}

Despite the very small size of our sample, some effects
of adding the verb-frame-factor can be observed. On the positive side, verbs are
not missing in MT output that often. On the negative side, translation of verbs
or nouns gets confused by the additional factor. Unfortunately, also the
percentage of correctly translated verb-modifier relations in cases where both
verb and modifier are fine decreased.

Unless the experiment is repeated with more training data and also with a larger
set of evaluated sentences, it is hard to make any conclusions. The
verb frame factor at least leads to some more verbs in MT output.


%VFF
%Rok	18 (58.1 %)
%Rbad	13 (41.9 %)
%Celkem	31 (100.0 %)


% BASE
%Rok	19 (63.3 %)
%Rbad	11 (36.7 %)
%Celkem	30 (100.0 %)




\subsubsection{Single-factored Results \toen{}}

Our primary interest was in \tocs{} translation but we also experimented with
\toen{} direction, mainly to allow for comparison with previous reported
results.

It should be noted that translating to English in our setting is easier. In
general, there are fewer word forms in English so language models face milder
data spareness and there are fewer chances to make an error (BLEU would notice).
Moreover, the particular test set we use contains input Czech text that came
from an English original and was translated sentence by sentence.  The Czech
thus probably does not exhibit full richness and complexity of word order and
language constructions and is easier to translate back to English than a generic
Czech text would be.


\begin{table}[ht]
\begin{center}
\small
\begin{tabular}{lccccc}
Scenario  &  Parallel Corpus  &  Language Models                &  Dev (std)  &  Dev (opt)  &  Test (opt)\\
\hline
T         &  Baseline (20k)   &  Baseline (20k)                 &      28.97  &      35.39  &        28.50\\
T+C       &  Baseline (20k)   &  Baseline (20k)                 &      23.07  &      36.13  &        28.66\\
T         &  Large (860k)     &  20k+860k                       &      19.31  &      39.60  &        33.37\\
T         &  Large (860k)     &  \clap{Large (860k, i.e. mix)}  &      28.94  &      40.15  &  \max{34.12}\\
\end{tabular}
\end{center}
\caption{Sample \toen{} BLEU scores.}
\label{english}
\end{table}

Table \ref{english} lists Moses results of \toen{} translation. We observe a
minor improvement when checking the part-of-speech factor (T+C). A larger
improvement is obtained
by adding more data and quite differently from \tocs{} results (see section
\ref{moredata}), mixing in-domain
and out-of-domain LM data does not hurt the performance.




\subsubsection{Summary and Conclusion}

We experimented with factored \tocs{} translation. The majority of our
experiments were carried out in a small data setting and we translated to a
morphologically rich language. In this setting, lemmatization or stemming of
training data is vital for obtaining reliable alignments. Multi-factored
translation for ensuring coherence of morphological properties of output words
significantly increases BLEU performance, although the effect is reduced with
additional training data. Experiments also indicate that more complex
translation scenarios lower the scores, probably due to more severe search
errors.

Our \tocs{} experiments confirm that in minimum-error-rate training, it is
helpful to keep language models based on in- and out-of-domain data separate. We
did not observe this domain sensitivity in \toen{} direction.

Based on manual analysis of sample output sentences, we also conducted some
preliminary experiments on using target-side syntactic information in order to
improve grammaticality of verb-modifier relations.  The results are rather
inconclusive and further refinement of the model would be necessary.



\subsection{Acknowledgement}

The work on this project was partially supported by the grants 
Collegium Informaticum GA\v{C}R 201/05/H014,
% doktorandsky
Grant No. 0530118 of the National Science Foundation of the USA,
% PIRE anglicky
and grants No. ME838 and GA405/06/0589.
% PIRE cesky.
The translation of reference sentences was supported by the grants
NSF 0122466 and M\v{S}MT \v{C}R 1P05ME786. The collection of additional training
data was supported by the grant GAUK 351/2005.
Any opinions, findings and conclusions or recommendations expressed in this
material are those of the authors and do not necessarily reflect the views of
the respective grant agencies.

I would like to express my gratitude to all members in our team for excellent
atmosphere and very pleasant collaboration. I also wish to thank specifically to
the leader of our team, Philipp Koehn, and the teachers Wade Shen and Marcello
Federico for full support and many stimulating comments and suggestions.
Finally, I cannot forget to mention the Center for Language and Speech Processing at Johns Hopkins
University for making this workshop possible.


}  % wrapping all Ondrej's content to prevent confusing macros


\section{Chinese-English}
{\sc Wade Shen}

\section{Confusion Network Decoding}
{\sc Wade Shen and Richard Zens}


\subsection{Results for the BTEC Task}

The experiments were carried out on the {\it Basic Travel Expression Corpus} (BTEC) task \cite{takezawa02}. 
This is a multilingual speech corpus which contains tourism-related sentences similar to those that are found in phrase books.
The corpus statistics are shown in Table~\ref{tab-corpus}.
For the supplied data track, 40\,000 sentences training corpus and three test sets were made available for each language pair.

\begin{table}
\begin{center}
\caption{Corpus statistics for the Chinese-English task.} \label{tab-corpus}
\begin{tabular}{|l|r|r|}
\hline
& Chinese & English \\
\hline
sentences & \multicolumn{2}{c|}{40 K} \\ \cline{2-3}
running words & 351 K  &  365 K \\
avg. sent. length& 8.8& 9.1 \\
vocabulary entries& 11 K & 10 K \\
\hline
\end{tabular}
\end{center}
\end{table}

%As the BTEC is a rather clean corpus, the preprocessing consisted mainly of tokenization, i.e., separating punctuation marks from words.
%Additionally, we replaced  contractions such as {\em it's} or {\em I'm} in the English corpus and we removed the case information.
%There was no special preprocessing for the Chinese and the Japanese training corpora.


\subsubsection{Chinese-to-English}

In this section, we will present the experimental results for the Chinese--English task.
The statistics of the confusion networks are summarized in Table~\ref{tab-ce-cn-stat}.
Note that the average length of the sentences in the \devfour\ test set is about twice as large as in the training data.
We also present the depths of the confusion networks. %, i.e. the number of alternatives per position.
On average we have  between two and three alternatives per position.
At some positions, however, there are more than 90 alternatives.
\begin{table}[t]
\begin{center}
\caption{Chinese--English: confusion network statistics for the \devfour\ test set (489 sentences).} \label{tab-ce-cn-stat}
\begin{tabular}{|l|r|r|}
\cline{2-3}
\multicolumn{1}{c}{}&\multicolumn{2}{|c|}{speech type} \\ \hline
& read  & spontaneous  \\
\hline
avg. length & 17.2 & 17.4 \\
avg. / max.  depth & 2.2  / 92 & 2.9 / 82  \\
avg. number of paths & $10^{21}$ & $10^{32}$ \\
\hline
\end{tabular}
\end{center}
\end{table}


In Table~\ref{tab-ce-cn-results}, we present the translation results for the Chinese--English task for different input conditions on the \devfour\ and the \eval\ test sets.
Comparing the translation results of 1-best and confusion network, we observe a small but consistent improvement for read speech.
For spontaneous speech, the improvements are larger, e.g. 1.1\% BLEU for the \eval\ test set.

\begin{table}[t]
\begin{center}
\caption{Chinese--English: translation results for different input types.} \label{tab-ce-cn-results}
\begin{tabular}{|c|l|c|c|}
\cline{3-4}
\multicolumn{2}{c}{}&\multicolumn{2}{|c|}{speech type} \\
\hline
test  && read  & spontaneous \\
set &input& BLEU [\%] & BLEU [\%] \\
\hline \hline
\devfour & verbatim & \multicolumn{2}{c|}{21.4} \\ \cline{2-4}
& 1-best  & 19.0 & 17.2 \\ 
\cline{2-4}
& full CN & 19.3 & 17.8 \\
\hline 
 \hline
 \eval & verbatim & \multicolumn{2}{c|}{21.4} \\ \cline{2-4}
 & 1-best  & 18.5 & 17.0 \\ 
\cline{2-4}
& full CN & 18.6 & 18.1 \\
\hline 
\end{tabular}
\end{center}
\end{table}

As described in Section~\ref{sec:repunct}, we did some experiments using the confusion network decoder for repunctuation.
The results are presented in Table~\ref{tab-ce-pm}.
We observe a small improvement when using a confusion network for the punctuations.
Note that this system was not optimized, so we might expect larger improvement when optimizing for this type of input.
\begin{table}[t]
\begin{center}
\caption{Chinese--English: translation results for punctuation insertion.} \label{tab-ce-pm}
\begin{tabular}{|l|c|}
\hline
punctuation input type & BLEU [\%]  \\ \hline
1-best & 20.8   \\  \hline
confusion network & 21.0  \\ 
\hline
\end{tabular}
\end{center}
\end{table}

	
\subsection{Results for the EPPS Task}
Additional experiments for confusion network decoding were carried out on the Spanish-to-English EPPS (European Parliament Plenary Sessions) task.
The training data was collected within the TC-Star project\footnote{http://www.tc-star.org} and is a superset of the Spanish--English EuroParl corpus (\cite{koehn:europarl:mtsummit:2005}).


\subsubsection{Corpus Statistics}
Statistics for this task are reported in Table~\ref{tbl:epps-corpstat}.  
The bilingual training corpus consists of about 1.3\,M sentence pairs with about 36\,M running words in each language.
The training was performed with the {\tt Moses} training tools, while training of the 4-gram target LM was performed with the IRST LM Toolkit.
Sentences in the dev and test sets are provided with two reference translations each.  
\begin{table}[t]
\begin{center}
\caption{Corpus statistics for the Spanish-English EPPS task.
% For development and test sets, figures related to Spanish refer to {\tt verbatim} input type, whereas figures related to English refer to the reference translations.
} \label{tbl:epps-corpstat}
\begin{tabular}{|l|l|r|r|}
 \hline
       &              &  Spanish   &   English     \\
\hline
Train  & Sentences    & \multicolumn{2}{c|}{1.3\,M}\\
\cline{2-4}
      & Words & 37\,M & 36\,M\\
\cline{2-4}
       & Vocabulary   & 143\,K & 110\,K\\
\cline{2-4}
       & Phrase Pairs   & \multicolumn{2}{c|}{83\,M}\\
\cline{2-4}
       & Phrases   & 48\,M & 44\,M\\
 \hline
Dev    & Utterances    &   \multicolumn{2}{c|}{2\,643} \\
 \cline{2-4}
       & Words& 20\,384 & 20\,579 \\ 
%\cline{2-4}
%       & Vocabulary   & 2\,883 &  2\,362 \\
 \hline
Test   & Utterances    & \multicolumn{2}{c|}{1\,073}  \\
 \cline{2-4}
       & Words& 18\,890 & 18\,758 \\
 \cline{2-4}
 %      & Vocabulary   & 3\,139 & 2\,567 \\
 %\cline{2-4}
%       & OOV Words & 145 & 44\\
 \hline
\end{tabular}
\end{center}
\end{table}


The ASR word lattices  were  kindly provided by CNRS-LIMSI, France.
The confusion networks and $N$-best lists were extracted using the {\tt lattice-tool} included in the SRILM Toolkit (\cite{stolcke:02}). 
%The consensus decoding transcriptions  were also extracted from the confusion networks, by taking the most probable words from  each column.
The statistics of the confusion networks for the Spanish--English EPPS task are presented in Table~\ref{tbl:epps-cn}.
The average depth of the confusion networks, i.e. the average number of alternatives per position, is 2.8 for the development set and 2.7 for the test set.
Note that the maximum depth is much larger, e.g. up to 165 for the development set.
Also, the average number of paths in the confusion networks is huge. 

\begin{table}[t]	
	\caption{Statistics of the confusion networks for the development and test sets of the Spanish--English EPPS task.}\label{tbl:epps-cn}
	\begin{center}
	\begin{tabular}{|l|r|r|}
	\hline
	& Dev & Test \\
	\hline
	Utterances & 2\,633  & 1\,071 \\
	Avg. length & 10.6 &  23.6 \\
	Avg. / max.  depth & 2.8  / 165 & 2.7 / 136  \\
	Avg. number of paths & $10^{38}$ & $10^{75}$ \\
	\hline
	\end{tabular}
	\end{center}
\end{table}


\subsubsection{Parameter Tuning}
The feature  weights of all models were optimized using minimum-error-rate training (\cite{och:03}) which tries to maximize the BLEU score on the development set.  
A special procedure was used for tuning the weights of the $N$-best translation system. 
First, a single best decoder was optimized over the development set. 
Then $M$-best translations were generated for each $N$-best input of the development set. 
Hence, all $N$x$M$ translations were merged and a new log-linear model  including the ASR additional features was trained. 


\subsubsection{Translation Results}

\begin{table}[t]
\caption{Translation performance achieved by {\tt Moses} for different input types for the test set of the Spanish--English EPPS task.}
\begin{center}
\begin{tabular}{|l|l||c||ccc|}
 %\hline
%\multicolumn{2}{|c|}{Input} &\multicolumn{3}{c|}{MT Quality}  \\
\hline
\multicolumn{2}{|c||}{Input Type}                & ASR WER [\%]     & BLEU [\%] 	& PER [\%] 	& WER [\%] \\
\hline \hline
\multicolumn{2}{|c||}{{\tt verbatim}}   & \phantom{0}0.00      & 48.00 & 31.19 & 40.96 \\
 \hline \hline
%{\tt oracle from wg} &\phantom{0}7.48     & 44.68 & 33.55 & 43.74 \\ 
%{\tt \phantom{oracle from} cn}  &\phantom{0}8.45     & 44.12 & 34.37 & 44.95 \\
 %\hline
ASR & {\tt 1-best, wg}        & 22.41 & 37.57 & 39.24 & 50.01 \\
&{\tt \phantom{1-best,} cn}  & 23.30  & 36.98 & 39.17 & 49.98  \\
 \cline{2-6}
&{\tt cn}               &\phantom{0}8.45     & 39.17 & 38.64 & 49.52 \\
 \cline{2-6}
&{\tt N-best, N=1}        & 22.41 & 37.57 & 39.24 & 50.01 \\
%{\tt 5-best}*      & 18.61 & 38.96 & 38.78 & 49.40 \\
&{\tt \phantom{N-best,} N=5}        & 18.61 & 38.68 & 38.55 & 49.33 \\
%{\tt 10-best}*    & 17.12 & 38.71 & 38.74 & 49.29 \\
&{\tt \phantom{N-best,} N=10}      & 17.12 & 38.61 & 38.69 & 49.46 \\
 \hline
 \end{tabular}
\end{center}
\label{tbl:epps-results}
\end{table}


In Table~\ref{tbl:epps-results}, we report the translation performance for different input types:
\begin{itemize}
\item {\tt verbatim}: These are the translation results for the correct transcriptions of the speech signal. Therefore, the ASR word error rate is 0.0\% for this input type.
%\item {\tt oracle}: These are the translation results for the best ASR transcriptions contained in the word graphs ({\tt wg}) and the confusion networks ({\tt cn}), respectively. 
\item {\tt 1-best}: Here, we have translated the single-best ASR transcription of the word graphs ({\tt wg}) and the confusion networks ({\tt cn}), respectively.
\item {\tt cn}: These are the results for decoding the full confusion networks.
\item {\tt N-best}: These are the results for $N$-best decoding with $N=1,5,10$.
\end{itemize}
The optimization of the system was performed separately for each input type, as described before.
In addition to the translation results, we also report the ASR word error rate.
Note that for the confusion network ({\tt cn}) and the $N$-best lists ({\tt N-best}) input types,  we reported the ASR WER of the best transcription contained in the confusion network or the $N$-best lists, respectively.
The comparison of the scores for the different input conditions %on the text inputs ({\tt verbatim}, {\tt wg-oracle}, {\tt cn-oracle}, {\tt 1-best}, and {\tt cons-dec})
shows a strong correlation between quality of the transcriptions given by the ASR WER and quality of the translation given by the MT scores.

Assuming a perfect ASR system, i.e. in the {\tt verbatim} condition, we achieve a BLEU score of 48\%.
Comparing this to the ASR input conditions, we observe a degradation of about 10 BLEU points in the case of ASR input.

The confusion network decoding ({\tt cn}) achieves the best BLEU score among the ASR input types. %, i.e. for all input types except {\tt verbatim}.
Note the large gain compared to the single-best input types, e.g. 1.6\% BLEU absolute over the single-best from the word graphs and even more over the single-best from the confusion networks.

In terms of WER and PER, the {\tt 5-best} system is slightly better.
%The translation of confusion networks ({\tt cn}) outperforms the translation of all  $N$-best lists with respect to BLEU, and only the translation of 1-best with respect to PER and WER. 
This could be due to the fact that the systems were optimized for BLEU.

\subsubsection{Efficiency}

Experimentally, the ratio between the decoding time for translating the confusion networks ({\tt cn}) and the single-best ({\tt 1-best}) is about 2.1 (87.5 vs 42.5 seconds per sentence). 
As the decoding time for $N$-best lists is proportional to $N$, we can claim that decoding CNs  is preferrable to translating $N$-best ($N>2$) with respect to translation speed, i.e. decoding confusion networks is more efficient than translating $N$-best lists.


In Figure~\ref{fig-cn-exploration}, we show the effect of the incremental pre-fetching of translation options for confusion network decoding.
The curve labeled 'CN total', represents the total number of paths in the confusion networks as a function of the path length.
This is the number of phrases enumerated using a naive pre-fetching algorithm.
Note the exponential growth with increasing path length.
Therefore, the naive algorithm is only applicable for very short phrases and heavily pruned confusion networks.
\begin{figure} 
	\begin{center}
		\includegraphics[width=0.75\linewidth]{CN_PathExploration}
		\caption{Exploration of the confusion networks for the Spanish--English EPPS task.}\label{fig-cn-exploration}
	\end{center}
\end{figure}
The next curve, labeled 'CN explored', is the number of paths that are actually explored using the incremental algorithm described in Section~\ref{sec:pre-fetching}.
We do {\em not} observe the exponential explosion as for the total number of paths.
%Thus, the presented algorithm effectively solves the combinatorial problem of matching phrases of the input \CN s and the phrase table.
For comparison, we also plotted the number of explored paths for the case of single-best input, labeled '1-best explored'.
The maximum phrase length in the phrase table for  these experiments is seven.
In the case of confusion network input, this length can be exceeded as the confusion networks may contain $\epsilon$-transitions.




\section{Tuning}
{\sc Nicola Bertoldi}
\label{sec:exp-tuning}
As stated in Section~\ref{sec:tuning}, training of {\tt Moses} also requires the optimization of the feature weights, which is performed through the there described MERT. We analized how much the experimental set up affects the effectiveness of this procedure. In particular, the amount of translation hypotheses extracted in each outer loop and the size of the development set are taken into account.

Experiments were carried out on two tasks, namely the translation of proceedings of 
the European Parliament from German into English, and the translation  of  speeches from the  European Parliament Plenary Sessions (EPPS) from Spanish to English.

\paragraph{The German-English EuroParl task}
\label{sec:ge-en-europarl-task}
EuroParl \cite{koehn:europarl:mtsummit:2005} is a collection of parallel text in 11 languages from the proceedings of the European Parliament. We worked on the German-English language pair. Training data consist of 751 K sentence pairs. 2000 sentences are provided both for parameter tuning and for testing.  Statistics about training data, development and test sets are reported in Table~\ref{tbl:ge-en-europarl-data}
Sentences in the development and test sets are provided with just 1 reference translation each.  

\begin{table}[th]
\begin{center}
\begin{tabular}{lrr|rr|rrr}
        &  \multicolumn{2}{c|}{Train}   &  \multicolumn{2}{c|}{Dev}    &  \multicolumn{2}{c}{Test}\\
 \hline
        &  Ger   &   Eng  &  Ger   &   Eng  &  Ger   &   Eng     \\
 \hline
Sentences    & \multicolumn{2}{c|}{751 K} & \multicolumn{2}{c|}{2,000} & \multicolumn{2}{c}{2,000}\\
Words & 15 M & 16 M & 55,136 & 58,652 & 54,247 & 57,945\\
Vocabulary  & 195 K & 66 K & 8,796 & 6,114& 8,668 & 6,054&\\
Phrase Pairs  & \multicolumn{2}{c|}{12 M}\\
Phrases & 9 M & 8 M \\
\end{tabular}
\caption{Statistics of the German-English EuroParl task. Word counts of  English dev and test sets refer
 the first reference translation. }
\begin{center}
\end{center}
\label{tbl:ge-en-europarl-data}
\end{center}
\end{table}

Models employed in the decoder were estimated with the {\tt Moses} toolkit. A 3-gram target language model was used.

\paragraph{The EPPS task}
\label{sec:epps-task}
The EPPS task consists in translating speeches from the  European Parliament  from Spanish to English, This task was organized in the TC-STAR 2005\footnote{http://www.tc-star.org} Evaluation Campaign. 

Speeches included in the development and test sets are automatically recognized by LIMSI, France, which kindly provided the word lattices, and Confusion Networks were extracted from them using the {\tt lattice-tool} software of the {\tt SRILM Toolkit} \cite{stolcke:02}. Instead, training data for the EPPS task consists of the Final Text Editions of the speeches, which are significantly human-revised versions of the simultaneous transcriptions.
Statistics about the training, development and testing  data are reported in Table~\ref{tbl:epps-data}.  
Sentences in the development and test sets are provided with two reference translations each.  


\begin{table}[th]
\begin{center}
\begin{tabular}{lrr|rr|rrr}
        &  \multicolumn{2}{c|}{Train}   &  \multicolumn{2}{c|}{Dev}    &  \multicolumn{2}{c}{Test}\\
 \hline
        &  Spa   &   Eng  &  Spa   &   Eng  &  Spa   &   Eng     \\
 \hline
Sentences    &   \multicolumn{2}{c|}{1,308 K} & \multicolumn{2}{c|}{2,643} & \multicolumn{2}{c}{1,073}\\
Words & 37 M & 36 M & 20,384 & 20,579 & 18,890 & 18,758\\
Vocabulary   & 143 K & 110 K & 2,883 &  2,362  & 3,139 & 2,567 \\
Phrase Pairs   & \multicolumn{2}{c|}{83 M}\\
Phrases   & 48 M & 44 M\\
\end{tabular}
\caption{Statistics of the EPPS speech translation task. Word counts of  dev and test sets sets refer
to human transcriptions (Spanish) and the first reference translation (English). }
\begin{center}
\end{center}
\label{tbl:epps-data}
\end{center}
\end{table}

Models were estimated with the {\tt Moses} training tools, apart from the 4-gram target LM which was trained with the IRST LM Toolkit on 47 M running words.


\paragraph{MERT vs. amount of translation alternatives}
First, we tested whether and how the amount of translation alternatives generated by {\tt Moses} impacts on the tuning. For this experiment the EuroParl task was selected. Several MERTs were performed constraining {\tt Moses} to generate a different number of translations in each outer loop ($N=100, 200, 400, 800$). The sets of weights obtained after each iteration of the outer loop are then used to translate the test set. Figure~\ref{fig:MERT-epps-nbest} shows the achieved BLEU score in the different conditions.

\begin{figure}[ht]
\begin{center}
\label{fig:MERT-epps-nbest}
 \includegraphics[width=0.75\columnwidth]{MERT-nbest}
\caption{Performance (BLEU score) achieved on the EuroParl test set using feature weights optimized exploiting an increasing number of translation alternatives of the development set.}
\end{center}
 \end{figure}

We observe that convergence is reached after few iterations (5-6). This fact is positive because it allows to run {\tt Moses} only few times.

The weights obtained in the first iterations seem to award the use large $N$, but this effects vanishes very soon because the set of translation alternatives is continuously enlarged.

The final sets of weights perform very similar for each experimental condition; this is also positive because a limited number of $N$-best can be extracted, speeding up both the translation process and the inner loop.


\paragraph{MERT vs. amount of translation alternatives}
We also tested the impact of the size of the development set on the MERT procedure in both EuroParl and EPPS tasks. 
From the  development set of the EuroParl we extracted 4 subsets of 100, 200 400 and 800 sentences, respectively. 529 sentences are randomly selected from the EPPS development set .
The sets of weights obtained after each iteration of the outer loop are then used to translate the corresponding test sets.

\begin{figure}
\begin{center}
\label{fig:MERT-europarl-devsize}
 \includegraphics[width=0.75\columnwidth]{europarl-devsize}
\caption{Performance (BLEU score) achieved on the EuroParl test set using feature weights optimized on  development sets of increasing size.}
\end{center}
 \end{figure}


\begin{figure}
\begin{center}
\label{fig:MERT-epps-devsize}
 \includegraphics[width=0.75\columnwidth]{epps-cn-devsize}
\caption{Performance (BLEU score) achieved on the EPPS test set using feature weights optimized on  development sets of increasing size.}
\end{center}
 \end{figure}

Figures~\ref{fig:MERT-europarl-devsize} and \ref{fig:MERT-epps-devsize} show the achieved BLEU score in the different conditions for the EuroParl and EPPS tasks, respectively.

Plots reveal that more stable and better results are obtained with weights optimized on larger dev set; moreover, EuroParl experiments show that MERT with larger dev set tends to end in less iterations.
In general, these experiments show that 2 iterations give the biggest relative  improvement and that next iterations, which slightly improve on the dev set, are risky on the test set.

This behavior is explained by the tendency of MERT procedure to overfit the development data. Possible ways to limit the overfitting problems consists in enlarging the dev set  and ending the tuning after few iterations.
The former solution increases the time of tuning, while the latter make it faster and more robust. with respect to differences between dev and test sets. It is also trivial to stress that the development  data should be as close as possible to the test domain.


\paragraph{Comparison of different optimization algorithm} We also compared our optimization algorithm against the downhill simplex algorithm. For this experiment we employed {\tt Moses} in the EPPS task.

Table~\ref{tbl:MERT-epps-algorithm} reports the increment of BLEU score achieved on the development and test sets after MERT; it shows that our approach is definitively competitive with (and slightly better than) the widely-used downhill simplex algorithm. The number of iterations to converge are similar, too.
Moreover, the improvements achieved on the dev and test sets are comparable.


 \begin{table}[ht]
\begin{center}
\label{tbl:MERT-epps-algorithm}
\begin{tabular}{l|ccc}
algorithm               & iteration & \multicolumn{2}{c}{$\Delta$ BLEU}\\
                                &                & dev & test\\
\hline
CLSP-WS              & 6 & +3.2 & +3.6 \\
downhill simplex  & 7 & +2.9  & +3.4\\
\end{tabular}
\caption{Performance improvement (absolute BLEU score) achieved on the EPPS task using two different optimization algorithm.}
\end{center}
\end{table}

\paragraph{MERT vs. different input types} Finally, we performed two separate MERT for the two input types handled by {\tt Moses}, namely text and Confusion Networks. The human transcriptions ({\tt verbatim}) and the CNs of the development data of the EPPS task were exploited. Weights optimized in the {\tt verbatim} condition were applied to translate both human transcriptions ({\tt verbatim}), the best automatic transcriptions ({\tt 1-best}),  and the consensus decoding transcriptions ({\tt 1-best-CN}) extracted from the CNs \cite{mangu:00} by taking the most probable words of  each column. Weights optimized in the {\tt CN} condition were applied to the CNs of the test set.
The increments achieved on the development and test data are reported in Table~\ref{tbl:MERT-epps-summary}.


 \begin{table}[ht]
\begin{center}
\label{tbl:MERT-epps-summary}
\begin{tabular}{l|cc}
input                    &\multicolumn{2}{c}{$\Delta$ BLEU}\\
                             & dev & test\\
\hline
{\tt verbatim}  &  +1.9 & +2.1\\
{\tt 1best}        &  +2.1 & +2.2\\
{\tt 1best-CN} &  +1.6 & +2.2\\
\hline
{\tt CN}            &  +3.2 & +3.6\\
\end{tabular}
\caption{Performance improvement  (absolute BLEU score) achieved on the EPPS task using different input types.}
\end{center}
\end{table}

We observe that improvement on the test set ranges from 2.1 to 3.6 absolute BLEU points, and that it is consistent between dev and test. The bigger increase for the CNs is probably due to a choice of the initial set of weights performing worse than the corresponding set for the {\tt verbatim} condition.


\section{Linguistic Information for Word Alignment}
%{\sc Alexandra Constantin}

\subsection{Word Alignment}

If we open a common bilingual dictionary, we may find an entry
like\\
\begin{center}
\textbf{Haus} = house, building, home, household\\
\end{center}
Many words have multiple translations, some of which are more likely
than others.

If we had a large collection of German text, paired with its
translation into English, we could count how often $Haus$ is
translated into each of the given choices. We can use the counts to
estimate a lexical translation probability distribution

\begin{center}
$t : e|f \rightarrow t(e|f)$
\end{center}

that, given a foreign word, $f$, returns a probability for each
choice for an English translation $e$, that indicates how likely
that translation is.


We can derive an estimate of the translation probability
distribution from the data by using the ratio of the counts. For
example, if we have $10000$ occurrences of $Haus$ and $8000$
translate to $house$, then $t(house|Haus)=0.8$.

For some words that are infrequent in the corpus, the estimates of
the probability distribution are not very accurate. Using other
linguistic information, such as observing that in a specific
language pair verbs usually get translated as verbs, could help in
building a more accurate translation.

Let's look at an example. Imagine we wanted to translate the German
sentence \textbf{\emph{das Haus ist klein}}. The sentence can be
translated word by word into English. One possible translation is
\textbf{\emph{the house is small}}.


Implicit in these translations is an alignment, a mapping from
German words to English words:

\includegraphics[viewport = 100 440 400 530,clip]{constantin-figure1.pdf}

An alignment can be formalized with an alignment function $a : i
\rightarrow j$. This function maps each English target word at
position $i$ to a German source word at position $j$.

For example, if we are given the following pair of sentences:

\includegraphics[viewport = 100 400 400 550,clip]{constantin-figure2.pdf}

the alignment function will be

$a:\{1 \rightarrow 3, 2 \rightarrow 4, 3 \rightarrow 2, 4
\rightarrow 1\}$.


\subsection{IBM Model 1}

Lexical translations and the notion of alignment allow us to define
a model capable of generating a number of different translations for
a sentence, each with a different probability. One such model is IBM
Model 1, which will be described below.

For each target word $e$ that is produced by the model from a source
word $f$, we want to factor in the translation probability $t(e|f)$.

The translation probability of a foreign sentence
$\textbf{f}=(f_1,\dots,f_{l_f})$ of length $l_f$ into an English
sentence $\textbf{e}=(e_1,\dots, e_{l_e})$ of length $l_e$ with an
alignment of each English word $e_j$ to a foreign word $f_i$
according to alignment $a:j \rightarrow i$ is:

\begin{center}
$p(\textbf{e},a|\textbf{f}) = \frac{\epsilon}{(l_f +
1)^{l_e}}\prod_{j=1}^{l_e} t(e_j|f_{a(j)})$
\end{center}


\subsection{Learning the Lexical Translation Model}

A method for estimating these translation probability distributions
from sentence-aligned parallel text is now needed.

The previous section describes a strategy for estimating the lexical
translation probability distributions from a word-aligned parallel
corpus. However, while large amounts of sentence-aligned parallel
texts can be easily collected, word-aligned data cannot. We would
thus like to estimate these lexical translation distributions
without knowing the actual word alignment, which we consider a
hidden variable. To do this, we use the Expectation-Maximization
algorithm:

\paragraph{EM algorithm}
\begin{itemize}
\item{Initialize model (typically with uniform distribution)}
\item{Apply the model to the data (expectation step)}
\item{Learn the model from the data (maximization step)}
\item{Iterate steps 2-3 until convergence}
\end{itemize}

First, we initialize the model. Without prior knowledge, uniform
probability distributions are a good starting point. In the
expectation step, we apply the model to the data and estimate the
most likely alignments. In the maximization step, we learn the model
from the data and augment the data with guesses for the gaps.

 \textbf{Expectation step}

When we apply the model to the data, we need to compute the
probability of different alignments given a sentence pair in the
data:

\begin{center}
$p(a|\textbf{e},\textbf{f}) =
\frac{p(\textbf{e},a|\textbf{f})}{p(\textbf{e}|\textbf{f})}$
\end{center}

$p(\textbf{e}|\textbf{f})$, the probability of translating sentence
$\textbf{f}$ into sentence $\textbf{e}$ is derived as:

\begin{center}

$p(\textbf{e}|\textbf{f}) = \sum_a p(\textbf{e},a|\textbf{f}) =
\prod_{j=1}^{l_e} \sum_{i=0}^{l_f}t(e_j|f_i)$
\end{center}

Putting the previous two equations together,

\begin{center}

 $p(a|\textbf{e},\textbf{f}) =
\frac{p(\textbf{e},a|\textbf{f})}{p(\textbf{e}|\textbf{f})}
=\prod_{j=1}^{l_e} \frac {t(e_j | f_{a(j)})}{\sum_{i=0}^{l_f}
t(e_j|f_i)}$.


\end{center}

\textbf{Maximization Step}

For the maximization step, we need to collect counts over all
possible alignments, weighted by their probabilities. For this
purpose, we define a count function $c$ that collects evidence from
a sentence pair $(\textbf{e},\textbf{f})$ that a particular source
word $f$  translates into a particular target word $e$.

\begin{center}

$c(e|f;\textbf{e},\textbf{f}) = \sum_a p(a|\textbf{e},\textbf{f}) =
\frac{t(e|f)}{\sum_{j=1}^{l_e}t(e|f_{a(j)})} \sum_{j=1}^{l_e}
\delta(e,e_j)\sum_{i=0}^{l_f}\delta(f,f_i)$

\end{center}

where $\delta(x,y)$ is $1$ is $x=y$ and $0$ otherwise.

Given the count function, we can estimate the new translation
probability distribution by:

\begin{center}
$t(e|f;\textbf{e},\textbf{f}) =
\frac{\sum_{(\textbf{e},\textbf{f})}c(e|f;\textbf{e},\textbf{f})}{\sum_f\sum_{(\textbf{e},\textbf{f})}c(e|f;\textbf{e},\textbf{f})}$.
\end{center}


\subsection{Introducing Part of Speech Information to the Model}
In order to introduce part of speech information to the model, we
need to consider the probability of translating a foreign word
$f_{word}$ with part of speech $f_{POS}$ into English word
$e_{word}$ with part of speech $e_{POS}$. In order words, we need to
consider the translation probability distribution $t(e|f)$, where
$e$ and $f$ are vectors, $e = (e_{word},e_{POS})$, $f = (f_{word},
f_{POS})$. In order to estimate this density function, we need to
make some independence assumptions. Depending on the independence
assumption, several models can be formed:

\paragraph{POS Model 1}

Assuming that words are independent from their parts of speech, we
can estimate the translation density as:

\begin{center}
$t(e|f) = t(e_{word}|f_{word}) * t(e_{POS}|f_{POS})$
\end{center}



\paragraph{POS Model 2}

Making weaker independence assumption, the translation density can
be estimated as:

\begin{center}

$t(e|f) = \lambda p(e_{POS}|e_{word})t(e_{word}|f_{word}) +
(1-\lambda) p(e_{word}|e_{POS}) t(e_{POS}|f_{POS})$
\end{center}

This model has the advantage that it can weigh the importance given
to part-of-speech information.

\subsection{Experiment}
To test whether part-of-speech information improves alignment
quality, we compared alignments generated using IBM Model 1,
alignments generated using only part-of-speech information, and
alignments generated using POS Model 1 against manual alignments.
The metric used to compare the alignments was $AER$ (alignment error
rate). The data consisted of European Parliament German and English
parallel corpora. Experiments were done using different sizes of
corpora. The scores are presented in the following table:

\begin{center}
\includegraphics[scale=0.75,viewport = 90 600 510 730,clip]{constantin-table.pdf}
\end{center}

The first row indicates the number of sentences used for training
and the first column indicates the model used to generate
alignments.

As expected, the $AER$ of the alignments generated using only part
of speech information are very high, indicating that part-of-speech
information is not sufficient to generate good alignments. However,
an $AER$ of around $.75$ indicates that there is some information
provided by part-of-speech information that could be useful.

The $AER$ of alignments generated with IBM Model 1 doesn't
statistically differ from the $AER$ of alignments generated with the
additional part of speech information. One reason for this might be
that the part-of-speech probability was given equal weight to the
word probability, even though the latter is more important. POS
Model 2 might thus generate an improvement in $AER$.



\chapter{Conclusions}
{\sc Philipp Koehn: Accomplishments}

\appendix

\chapter{Follow-Up Research Proposal\\
A Syntax and Factor Based Model for Statistical Machine Translation}

\newcommand{\gen}{\hbox{GEN}}
\newcommand{\rep}{\bar{\phi}}
\newcommand{\Rep}{{\Phi}}
\newfont{\msym}{msbm10}
\newcommand{\reals}{\mbox{\msym R}}
\newcommand{\pav}{\bar{\alpha}}
\newcommand{\ip}[2]{{#1} \cdot {#2}}
\def\parcite#1{(\cite{#1})}
\def\perscite#1{\cite{#1}} % works like acl-style \newcite

\section{Introduction}
\label{intro}

This year's Summer Workshop on Language Engineering at Johns Hopkins
University focused in part on the development of an open source
toolkit for statistical machine translation
(SMT).\footnote{http://www.clsp.jhu.edu/ws2006/groups/ossmt/} The
toolkit's decoder, known as {\em Moses}, replicates the functionality
exhibited by the phrase-based decoder Pharaoh \parcite{koe:04}. One of
the weaknesses of traditional phrase-based models is their inability
to incorporate syntactic information in a direct and overt manner. For
instance, most English sentences contain a subject and a verb, but
there is no straightforward way to model this fact within the
phrase-based framework. Furthermore, there are translation
correspondences that are simple to describe using part-of-speech
information but difficult to model using lexical items
alone.\footnote{E.g., a French noun phrases that has the
part-of-speech sequence {\em determiner noun adjective} will most
likely in English be {\em determiner adjective noun}.} Moses addresses
the latter problem by extending the phrase-based framework to include
{\em factors}; hence, it exemplifies a {\em factor-based approach} to
statistical machine translation. Factor-based models behave much like
phrase-based models, but have the additional capability to take into
account information such as morphology and parts of speech, lemmas,
and phrase bracketing in the source and/or target languages during
decoding.

The experimental results from this summer's workshop indicate that
using factors can indeed improve translation performance. However,
observation of Moses' translation output indicates that, even when
BLEU scores improves, the system often does not adhere to basic global
syntactic constraints\footnote{We use the word {\em global} here to
refer to properties that require examination of the clause in its
entirety, such as {\em a clause will usually contain a finite verb}
and {\em a clause will never have more than one finite verb}.} of the
target language. We propose to address this problem by using a
syntax-based system that explicitly models syntactic constraints in
conjunction with the factor-based system developed this summer. A
baseline version of the syntax-based system has been implemented at
the Laboratory for Computer Science and Artificial Intelligence
(CSAIL) at MIT \parcite{cow:06}. A fundamental component of this system
is a discriminatively-trained model that takes as input a
source-language parse tree and produces a detailed target-language
syntactic structure called an {\em aligned extended projection}, or
AEP. AEPs may include information such as the main verb of the output
sentence, the number and type of its arguments, and the correspondence
(alignment) between source-side and target-side modifiers. The
discriminative AEP model provides an extremely flexible framework for
experimentation with a variety of language pairs and treebanking
styles. Most importantly, it provides a framework for modeling global
sytactic constraints of both the target language, as well as syntactic
correspondences between the source and target language.

This proposal is structured as follows: we continue this section with
some background on phrase-based and factor-based approaches to SMT; in
Section~\ref{framework}, we describe the syntax-based model in more
detail; and in Section~\ref{future}, we outline the work that we
propose to carry out this year to integrate the syntax-based and the
factor-based models.

\subsection{From Phrase-Based to Factor-Based Translation}
Phrase-based systems (e.g., \parcite{koe:04,koe:03,ochney:02,ochney:00})
advanced the state of the art in statistical machine translation
during the early part of this decade. They surpassed the performance
of earlier models, proposed by researchers at IBM and known as the
{\em IBM models} \parcite{bro:93}, which used alignments between words
(predicted using the EM algorithm) to estimate the values of
translation parameters in a generative model.  Phrase-based models
combine the word alignments induced by the earlier SMT models to
produce alignments between substrings of source and target text,
which, in these models, are called {\em phrases}.\footnote{Note that
these phrases do not have to be phrases in any linguistic sense.}
These phrasal translations, together with a search algorithm that
looks for a high-scoring solution, form the basis of the phrase-based
framework.

The current state-of-the-art phrase-based systems are log-linear
models of the conditional probability of the target ($e$) given the
source ($f$):

\begin{equation}
Pr(e|f) = \frac{\exp{\sum_{i} \lambda_i h_i(e,f)}}{\sum_{e'} \exp{\sum_{i} \lambda_i h_i(e',f)}}
\label{loglinear}
\end{equation}

\noindent
The $\lambda_i$ are weights on feature functions $h_i(e,f)$. The
weights are usually trained using minimum error rate training
\parcite{och:03}, although recently an online perceptron training
algorithm has also been shown effective \parcite{lia:06}. There are
usually on the order of ten feature functions, among which may be

\begin{itemize}
\item bidirectional phrase models (models that score phrasal translations);
\item bidirectional lexical models (models that consider the
appearance of entries from a conventional translation lexicon in the
phrasal translation);
\item $n$-gram target-language models ($n$-th order Markov models
whose parameters are trained on large amounts of monolingual data; the
probability of each word in a phrase is conditioned on the preceding
$n-1$ words, and the probability of the phrase is the product of the
probabilities the words);
\item distortion models (models that consider how source phrases get
reordered in the translation).
\end{itemize}

Phrase-based models address a severe limitation of the early
word-based models, which are restricted to many-to-one mappings
between source and target words. This means that if the Spanish phrase
{\em el libro del ni\~{n}o} were translated as {\em the boy's book} in
the data, the pairing between {\em el libro} and {\em book} would be
allowed when translating from Spanish to English, but not from English
to Spanish. In contrast, phrase-based models allow for the alignment
of multi-word units such as {\em the white house} with {\em la casa
blanca}, {\em and so on and so forth} with {\em etc\'{e}tera}, and
{\em big crimes need} with {\em los grandes cr\'{i}menes
necesitan}.\footnote{Note that the final phrasal alignment involves
phrases that cross syntactic phrasal boundaries. For example, {\em big
crimes} is a noun phrase, and {\em need} is part of a verb phrase.}

The use of many-to-many phrasal alignments means that these systems
can capture some lexical reorderings as well as the translation of
idiomatic expressions.  For example, consider the phrasal translation
pair {\em the white house} and {\em la casa blanca}. The
positions of the English noun {\em house} and the adjective {\em
white} are reversed relative to the positions of the Spanish noun {\em
casa} and adjective {\em blanca}. Figure~\ref{localreorder}
illustrates this swapping phenomenon. By learning that these phrases
are common translations of one another, the system has a better chance
of outputting the words in this phrase in the correct order. The IBM
models have to learn how to reorder all of the words in the sentence
as distinct units.

\begin{figure}
\centering
\includegraphics[scale=1]{brooke-localreorder}
\caption{When translating between Spanish and English, the positions
of nouns and their modifying adjectives are usually
swapped. Similarly, possessives in English generally precede nouns,
whereas in Spanish they follow the noun.}
\label{localreorder}
\end{figure}

The generalization capabilities of phrase-based systems are limited
due to their lack of direct, explicit knowledge of syntax. For
example, as we have seen, Spanish adjectives tend to follow the noun
they modify, a relative ordering that is the opposite of what is found
in English. But while phrase-based models can model this swapping more
easily than the IBM models can --- by essentially memorizing these
correspondences\footnote{The IBM models require the target phrase to
be a single word and therefore cannot memorize such correspondences.}
--- they have no mechanism for generalizing this phenomenon to novel
input phrases. Hence, if the phrase {\em the purple apples} is seen
during testing but not training, the system is forced to translate the
words individually and relies on a different part of the system (i.e.,
another component model in the log-linear framework, such as the
distortion model) to make a prediction about their relative order.

Factor-based translation is equipped to make this kind of
generalization. These models can, for instance, make use of
part-of-speech information to express the fact that, even though {\em
the purple apples} has not been seen, the part-of-speech sequence {\em
determiner adjective noun} has been seen, and quite often its
translation has the part-of-speech sequence {\em determiner noun
adjective}. Furthermore, if {\em the purple apple} has been seen, the
framework has the ability to model the fact that {\em apple} is the
lemma form of {\em apples}; the system can therefore make use of the
translation {\em las manzanas moradas} to derive the singular version
{\em la manzana morada}. More often than not, in the face of novel
test strings, phrase-based systems to do not get the ordering
correct.

Preliminary experimental results from this summer's workshop indicate
that using factors can indeed improve translation performance. For
instance, we ran a number of experiments at this summer's workshop
that used morphological information when translating from English to
Spanish. The morphological features we used included those shown in
Table~\ref{morph}. The use of the morphology improved the BLEU score
by approximately 1.3 points over a phrase-based baseline (i.e., a
model without any added factor information), from 23.41 to 24.66
BLEU. This gain was induced by using a language model trained with
sequences in which the words of the original training data were
replaced by strings representing their morphological features. During
decoding, the factor-based model predicts the morphology of a
translation hypothesis, and the score of the morphological language
model is combined in the overall score of the hypothesis.

\begin{table}
\begin{center}
\begin{tabular}{|c|l|}
\hline
{\bf Category} & {\bf Attributes} \\
\hline
Adjective & gender, number \\
\hline
Determiner & gender, number, person, possessor \\
\hline
Noun & gender, number \\
\hline
Verb & gender, number, person, mode, tense \\
\hline
Pronoun & gender, number, person, case, possessor \\
\hline
\end{tabular}
\end{center}
\caption{The morphological features used in English-to-Spanish
translation experiments with a factor-based model.}
\label{morph}
\end{table}

\subsection{Motivation for a Syntax-Based Model}
While factor-based models show tremendous promise in solving some of
the gravest deficiencies of phrase-based systems, there remain some
problems that are unlikely to be addressed. During decoding, the
output of factor-based translation is constructed incrementally and
left-to-right. These partial translations are also scored
incrementally so as to make the computation tractable. This means that
the component models $h_i(e,f)$ in equation~\ref{loglinear} cannot
look globally at the translation to see whether it upholds global
syntactic constraints of the target language. For instance, it is
difficult to model the fact that in English, clauses usually have a
single finite verb and a subject.

The output in Table~\ref{SMTexamples} is taken from a state-of-the-art
phrase-based SMT system translating from German to English (the
baseline system described in \perscite{col:05}). This
system has been trained using over 700K sentence pairs from the
European Parliament dataset \parcite{koe:05}. These examples represent a
few of the syntactic errors this system tends to make. We consider
each example in turn, discussing some, but not all, of the problems:

\begin{itemize}
\item[1:] 
\begin{itemize}
\item[$\bullet$] In the first clause, the substring {\em human rights practical}
introduces an unlikely ordering of a noun phrase {\em human rights}
and adjective {\em practical}.
\item[$\bullet$] In the second clause, there are two finite verbs ({\em must} and
{\em are}).
\end{itemize}
\item[2:]
\begin{itemize}
\item[$\bullet$] The clause beginning with {\em the convention...} introduces two
adjacent noun phrases {\em ...a draft a charter...}, which is an
unlikely event.
\item[$\bullet$] The prepositional phrase {\em in the hands of the council}
appears before the verb it modifies ({\em laid}), which is unusual in
English.
\item[$\bullet$] The verb phrase {\em has formulated} has been split by elements
that normally would not split a verb phrase.
\item[$\bullet$] The adjective {\em remarkable} is following the noun {\em way}.
\item[$\bullet$] There is a missing referring pronoun ({\em it}). I.e., the final
part of the sentence should say something like {\em ...laid it in the
hands of the council}.
\end{itemize}
\item[3:]
\begin{itemize}
\item[$\bullet$] The infinitival phrase {\em to maintain} follows its
noun phrase modifier.
\end{itemize}
\item[4:]
\begin{itemize}
\item[$\bullet$] The verb phrase {\em will...erected} is not syntactically
well-formed (the insertion of the verb {\em be} would make it so).
\end{itemize}
\item[5:]
\begin{itemize}
\item[$\bullet$] The first part of the sentence could be rendered as
two clauses {\em it seems to us the budget perspectives are not
appropriate}, in which case there is a missing subject {\em it} and a
missing verb {\em are}; alternatively, it could be rendered as a
single clause {\em the budget perspectives seem to us not
appropriate}, in which case the subject of the sentence has been
placed after the verb, and there is lack of agreement between the
subject and the verb.
\end{itemize}
\end{itemize}

While this output is taken from a phrase-based, and not a
factor-based, system, we argue that many of the syntactic errors,
particularly those that are global in nature, will not be corrected by
a factor-based system. For example, the misplacement of verbs with
respect to their modifiers, as in examples 2 and 3, is a very common
error. The problem stems from the fact that in independent clauses in
German, the finite verb is placed in the second position of the
sentence, and the infinitival verb, if it exists, is placed in the
final position. This means that in the English translation, the
infinitival verb may have to be moved across an arbitrary number of
intervening modifiers. Since phrase-based (and factor-based) systems
tend to either penalize translations that move phrases around too much
or to explicitly limit the absolute distance that phrases can move
(compromising the exactness of the search for efficiency), the output
tends mimic the word ordering of the input.

\begin{table}
\caption{Some examples of SMT output using a state-of-the-art
phrase-based system from German to English.}
\begin{center}
\begin{tabular}{p{2.25in}p{2.25in}}
{\bf SMT Output} & {\bf Reference Translation}\\
\hline
thus the implementation of human rights practical can be monitored , the union must have clear rules on possible penalties against the member states are available . & for the implementation of human rights to be monitored in practice also , however , the union must have clear rules regarding possible sanction mechanisms to be used against member states . \\
\hline
mr president , ladies and gentlemen , under the applause of the courts in luxembourg and strasbourg , the convention has a draft a charter of fundamental rights in a balanced way remarkable and formulated in the hands of the council laid . & mr president , ladies and gentlemen , with the approval of the courts in luxembourg and strasbourg , the convention has put together a draft charter of fundamental rights which is remarkably balanced , and has delivered it into the hands of the council . \\
\hline
i am with him that it is necessary , the institutional balance by means of a political revaluation of both the commission and the council to maintain . & i agree with him on the need to maintain the institutional balance and enhance the role , in political terms , of both the commission and the council . \\
\hline
irrespective of this , however , i should like to ask for this future is not already expect tomorrow , because they will gradually , stone for stone , erected . & that is why i invite you , in spite of everything , not to throw yourselves headlong into the future , as this is a future that should be built step by step , and stone by stone . \\
\hline
fifthly , seems to us the budget perspectives not appropriate... & fifthly , we also feel that the budgetary forecasts are not sufficient... \\
\hline
\end{tabular}
\end{center}
\label{SMTexamples}
\end{table}%

Other elements such as subjects and objects may also need to be
reordered to produce syntactically-sound output. Consider, for
instance, translation of the following German sentence into English:
{\em f\"{u}r seinen bericht m\"{o}chte ich dem berichterstatter
danken}. The English translation of this sentence, {\em i would like
to thank the rapporteur for his report}, involves a considerable
amount of reordering of the top-level phrases in the sentence (see
Figure~\ref{movement}): the subject {\em ich} moves from after the
German modal verb {\em m\"{o}chte} to the front of the English
translation; the prepositional-phrase modifier {\em f\"{u}r seinen
bericht} moves from the front of the sentence to after the object in
the English.

\begin{figure}
\centering
\includegraphics[scale=1]{brooke-movement}
\caption{The relative positioning of the top-level (bracketed) phrases
changes considerably in translation German to English.}
\label{movement}
\end{figure}

Figure~\ref{freeorder} shows three variations of the German sentence
introduced above with roughly the same meaning, illustrating how the
modifiers are relatively free to move around.\footnote{German is often
characterized as a {\em V2} language due to the obligatory placement
of the finite verb in the second position in declarative sentences.}
In contrast, the placement of phrases in English is generally more
constrained: the subject of an English sentence is almost always
placed before the verb; the object almost always comes after the
verb. Hence, English is known as a predominantly {\em
subject-verb-object}, or {\em S-V-O}, language. Therefore, when
translating from German to English, there is likely to be quite a bit
of reordering of top-level phrases.

\begin{figure}
\centering
\includegraphics[scale=1]{brooke-freeorder}
\caption{In German, the top-level phrases can move around positionally
in the sentence without significantly altering its meaning. In the
example, the subject ({\em ich}), object ({\em dem berichterstatter}),
and a prepositional-phrase modifier ({\em f\"{u}r seinen bericht})
exhibit such behavior.}
\label{freeorder}
\end{figure}

The reordering of top-level phrases can also be quite common when
translating between two fixed-word-order languages whose basic word
orders differ. For instance, Turkish, Japanese, and Korean, among many
of the world's other languages exhibit {\em subject-object-verb} word
order. Figure~\ref{basicorder} shows how key sentential elements move
around in languages with different basic word orders.

\begin{figure}
\centering
\includegraphics[scale=1]{brooke-basicorder}
\caption{The relative positions of the subject, verb, and object may
be different for different languages.}
\label{basicorder}
\end{figure}

Reordering poses a considerable challenge for phrase-based translation
systems. Factor-based systems have the potential to model reordering
based on, for instance, part of speech rather than words (i.e.,
factor-based distortion models). Indeed, some recent work has in fact
shown some improvement in translation quality by using part-of-speech
information in the distortion model \parcite{lia:06}. However, there are
other global syntactic constraints concerning the presence of
subjects, objects, verbs, and verbal modifiers, for instance, are
difficult to enforce within the phrase-based framework, and will very
likely be difficult to enforce within the factor-based framework as
well. Our observations of output produced by Moses this summer are
consistent with this conjecture. For instance, missing verbs in
sentences continues to be a problem with Moses, as it was with
Pharaoh.

Our syntax-based model makes predictions about the roles of top-level
phrases in the source-language input, as well as their positions in
the target-language output. This approach directly addresses the
global syntactic constraints, described above, which cannot easily be
modeled by a factor-based model. We propose using this model to
automatically reorder the input such that it more closely resembles
the syntactic ordering of the target language; we also propose making
use of the syntactic role information (e.g., {\em subject}, {\em
object}, etc.) that the model predicts to better constrain the output
of the factor-based system. Finally, by translating certain parts of
the sentence prior to using the factor-based system, we intend to
ensure that certain essential parts of the sentence (such as the verb,
any wh-words or complementizers, etc.) appear in the output. Before
providing a detailed outline of our proposed integrated syntax and
factor based system, we describe our syntax-based model.

\section{The Syntax-Based Component}
\label{framework}

This section is based on work we have done at MIT CSAIL on a framework
for {\em tree-to-tree} based statistical translation \parcite{cow:06}.
We focus here on one component of this framework: a model that
predicts {\em aligned extended projections}, or AEPs. AEPs are derived
from the concept of an {\em extended projection} in lexicalized tree
adjoining grammars (LTAG) \parcite{fra:02}, with the addition of
alignment information that is based on work in synchronous LTAG
\parcite{shisch:90}. The AEP model maps parse trees in the source
language to parse trees in the target language. We use a feature-based
model with a perceptron learning algorithm to learn this mapping. The
model is learned from a corpus of translation pairs, where each
sentence in the source or target language has an associated parse
tree.  We see two major benefits of tree-to-tree based
translation. First, it is possible to explicitly model the syntax of
the target language, thereby improving grammaticality. Second, we can
build a detailed model of the correspondence between the source and
target parse trees, thereby attempting to construct translations that
preserve the meaning of source language sentences.

Our AEP prediction framework involves a two-step process (described
below). We will use the German sentence {\em wir wissen da\ss\,das
haupthemmnis der vorhersehbare widerstand der hersteller war} as a
running example. For this example we take the desired translation to
be {\em we know that the main obstacle has been the predictable
resistance of manufacturers}.

\paragraph{Step 1:} The German sentence is parsed and then broken
down into separate parse structures for a sequence of clauses. For
example, the German example above is broken into a parse structure for
the clause {\em wir wissen} followed by a parse structure for the
subordinate clause {\em da\ss $\ldots$war}.

\paragraph{Step 2:} An AEP is predicted for
each German clause. To illustrate this step, consider translation of
the second German clause, which has the following parse structure:

\begin{small}
\begin{tabbing}
$\;$\hspace{1cm} s-oc \=kous-cp da\ss\\
       \>np-sb\avmbox{1} \= \=art das\\
                     \>\>\>nn haupthemmnis\\
       \>np-pd\avmbox{2} \> \>art der\\
                     \>\>\>adja vorhersehbare\\
                     \>\>\>nn widerstand\\
               \>\>np-ag \= \=art der\\
                               \>\>\>\>nn hersteller\\
       \>vafin-hd war
\end{tabbing}
\end{small}
Note that we use the symbols $\avmbox{1}$ and $\avmbox{2}$ to identify
the two modifiers (arguments or adjuncts) in the clause, in this case
a subject and an object.

A major part of the AEP is a parse-tree fragment, that is similar to a
TAG elementary tree (see also Figure~\ref{fig-aeps}):

\begin{center}
\begin{small}
\includegraphics[scale=1]{brooke-AEP}
\end{small}
\end{center}

\noindent
Following the work of \perscite{fra:02}, we will refer to a
structure like this as an {\em extended projection} (EP). The EP
encapsulates the core syntactic structure in the English clause.  It
contains the main verb {\em been}, as well as the function words {\em
that} and {\em has}. It also contains a parse tree ``spine'' which has
the main verb {\em been} as one of its leaves, and has the clause
label {\tt SBAR} as its root. In addition, it specifies positions for
arguments in the clause---in this case NPs corresponding to the
subject and object.

An AEP contains an EP, as well as {\em alignment information} about
where the German modifiers should be placed in the extended
projection. For example, the AEP in this case would contain the tree
fragment shown above, together with an alignment specifying that the
modifiers $\avmbox{1}$ and $\avmbox{2}$ from the German parse will
appear in the EP as subject and object, respectively. In summary, an
AEP encapsulates the core syntactic structure of the English clause,
as well as information about where the translations of German
modifiers should appear.

AEPs are detailed structural objects, and their relationship to the
source-language clause can be quite complex. We use a discriminative
feature-based model, trained with the perceptron algorithm, to
incrementally predict the AEP in a sequence of steps. At each step we
define features that allow the model to capture a wide variety of
dependencies within the AEP itself, or between the AEP and the
source-language clause.

\subsection{Aligned Extended Projections (AEPs)}
\label{sec-aep}
We now provide a detailed description of AEPs.  Figure~\ref{fig-aeps}
shows examples of German clauses paired with the AEPs found in
training data.\footnote{Note that in this work we consider translation
from German to English; in the remainder of the section we take {\em
English} to be synonymous with the target language in translation and
{\em German} to be synonymous with the source language.}  The German
clause is assumed to have $n$ (where $n \geq 0$) modifiers. For
example, the first German parse in Figure~\ref{fig-aeps} has two
arguments, indexed as $1$ and $2$. Each of these modifiers must either
have a translation in the corresponding English clause, or must be
deleted.

\begin{figure}
\begin{center}
\begin{small}
\begin{tabular}{|l|l|}
\hline
German Clause&English AEP\\
\hline
\hline
\parbox{1.5in}{
\begin{tabbing}
s-oc \=kous-cp da\ss\\
       \>np-sb\avmbox{1} \= \=art das\\
                     \>\>\>nn haupthemmnis\\
       \>np-pd\avmbox{2} \> \>art der\\
                     \>\>\>adja vorhersehbare\\
                     \>\>\>nn widerstand\\
               \>\>np-ag \= \=art der\\
                               \>\>\>\>nn hersteller\\
       \>vafin-hd war
\end{tabbing}

Paraphrase: {\em that [np-sb the main obstacle] 
[np-pd the predictable resistance of manufacturers]
was}

}
&
\parbox{1.5in}{
\begin{tabbing}
STEM: be\\
SPINE:\\
\=SBAR-A \=IN that\\
                     \>\>S \=NP-A\\
                         \>\>\>VP \=V\\
                            \>\>\>\>NP-A\\
\end{tabbing}
\begin{tabbing}
VOICE:     \hspace{0.5cm}\=active\\
SUBJECT:   \>\avmbox{1}\\
OBJECT:    \>\avmbox{2}\\
MODALS:     \>has\\
INFL:      \>been\\
\end{tabbing}}\\
\hline
\hline
\parbox{1.5in}{
\begin{tabbing}
s   \=pp-mo\avmbox{1} \= \=appr zwischen\\
                    \>\>\>piat beiden\\
                    \>\>\>nn gesetzen\\
    \>vvfin-hd bestehen\\
    \>adv-mo\avmbox{2} also\\
    \>np-sb\avmbox{3} \> \>adja erhebliche\\
                \>\>\> \=adja rechtliche\\
                       \>\>\>\>\$, ,\\
                       \>\>\>\>adja praktische\\
                       \>\>\>\>kon und\\
                       \>\>\>\>adja wirtschaftliche\\
                \>\>\>nn unterschiede
\end{tabbing}

Paraphrase: {\em [pp-mo between the two pieces of legislation] 
exist so [np-sb significant legal, practical and economic differences]}\\

}
&
\parbox{1.5in}{
\begin{tabbing}
STEM: be\\
SPINE:\\
S \= NP-A\\
  \>VP \= V\\
     \>\> NP-A\\
\end{tabbing}
\begin{tabbing}
VOICE:     \hspace{0.5cm}\=active\\
SUBJECT:   \>``there''\\
OBJECT:    \>\avmbox{3}\\
MODALS:     \>NULL\\
INFL:      \>are\\
MOD1: \> post-verb\\
MOD2: \> pre-sub\\
\end{tabbing}}\\
\hline
\hline
\parbox{1.5in}{
\begin{tabbing}
s-rc   \=prels-sb die\\
       \>vp \=pp-mo\avmbox{1} \= \=appr an\\
                         \>\>\>\>pdat jenem\\
                         \>\>\>\>nn tag\\
             \>\>pp-mo\avmbox{2} \> \=appr in\\
                           \>\>\>\>ne tschernobyl\\
               \>\>vvpp-hd gez\"{u}ndet\\
       \>vafin-hd wurde
\end{tabbing}

Paraphrase: {\em which [pp-mo on that day] [pp-mo in chernobyl] released were}

}
&
\parbox{1.5in}{
\begin{tabbing}
STEM: release\\
SPINE:\\
SBAR \=WHNP\\
     \>SG-A VP V\\
\end{tabbing}
\begin{tabbing}
VOICE: \hspace{0.5cm}\=passive\\
WH:      \> which\\
MODALS:  \>  was\\
INFL:    \> released\\
MOD1:    \> post-verb  \\
MOD2:    \> post-verb
\end{tabbing}}\\
\hline
\end{tabular}
\end{small}
\end{center}
\caption{Three examples of German parse trees, together with their
  aligned extended projections (AEPs) in the training data. Note that AEP elements whose value is {\em null} are not shown.
}
\label{fig-aeps}
\end{figure}

An AEP consists of the following parts:\footnote{Note that the
variables {\tt STEM}, {\tt SPINE}, {\tt VOICE}, {\tt WH}, {\tt
MODALS}, and {\tt INFL} essentially describe the EP of the English
main verb in the clause; the remaining variables {\tt SUBJECT}, {\tt
OBJECT}, and {\tt MOD(i)} specify the position of modifiers in the
German clause.}

\paragraph{STEM:} A string specifying the stemmed form of the
main verb in the clause.

\paragraph{SPINE:} A syntactic structure associated with the main verb. 
  The structure has the symbol {\tt V} as one of its leaf nodes; this
  is the position of the main verb. It includes higher projections of
  the verb such as VPs, Ss, and SBARs. It also includes leaf nodes
  {\tt NP-A} in positions corresponding to noun-phrase arguments
  (e.g., the subject or object) of the main verb. In addition, it may
  contain leaf nodes labeled with categories such as {\tt WHNP} or
  {\tt WHADVP} where a wh-phrase may be placed. It may include leaf
  nodes corresponding to one or more complementizers (common examples
  being {\em that}, {\em if}, {\em so that}, and so on).

\paragraph{VOICE:} One of two alternatives, {\tt active} or 
{\tt passive}, specifying the voice of the main verb.

\paragraph{SUBJECT:} This variable can be one of three types. If there
is no subject position in the {\tt SPINE} variable, then the value for
{\tt SUBJECT} is {\tt NULL}. Otherwise, {\tt SUBJECT} can either be a
string, for example {\em there},\footnote{This happens in the case
where there exists a subject in the English clause but not in the
German clause. See, for instance, the second example in
Figure~\ref{fig-aeps}.} or an index of one of the $n$ modifiers in the
German clause.

\paragraph{OBJECT:} This variable is similar to {\tt SUBJECT}, and can
also take three types: {\tt NULL}, a specific string, or an index of
one of the $n$ German modifiers. It is always {\tt NULL} if there is
no object position in the {\tt SPINE}; it can never be a modifier
index that has already been assigned to {\tt SUBJECT}.

\paragraph{WH:} This variable is always {\tt NULL} if there is no
wh-phrase position within the {\tt SPINE}; it is always a
non-empty string (such as {\em which}, or {\em in which}) if a
wh-phrase position does exist.

\paragraph{MODALS:} This is a string of verbs that constitute the
modals that appear within the clause. We use {\tt NULL} to signify
that there are no modals.

\paragraph{INFL:} The inflected form of the verb.

\paragraph{MOD(i):} There are $n$ modifier variables {\tt
  MOD(1), MOD(2), $\ldots$, MOD(n)} that specify the positions for
German arguments that have not already been assigned to the {\tt
SUBJECT} or {\tt OBJECT} positions in the spine. Each variable {\tt
MOD(i)} can take one of five possible values:

\begin{itemize}
\item {\tt null}: This value is chosen if and only if the modifier has
  already been assigned to the subject or object position.
\item {\tt deleted}: This means that a translation of the $i$'th
  German modifier is not present in the English clause.
\item {\tt pre-sub}: The modifier appears after any complementizers or
  wh-phrases, but before the subject of the English clause.
\item {\tt post-sub}: The modifier appears after the subject of the
  English clause, but before the modals.
\item {\tt in-modals}: The modifier appears after the first modal in
  the sequence of modals, but before the second modal or the main
  verb. 
\item {\tt post-verb}: The modifier appears somewhere after the main
  verb. 
\end{itemize}


\subsection{A Discriminative Model for AEP Prediction}
\label{sec-model}
In this section we describe linear history-based models with beam
search, and the perceptron algorithm for learning in these
models. These methods will form the basis for our model that maps
German clauses to AEPs.

We have a training set of $n$ examples, $(x_i,y_i)$ for $i = 1 \ldots
n$, where each $x_i$ is a German parse tree, and each $y_i$ is an AEP.
We follow previous work on history-based models, by representing each
$y_i$ as a series of $N$ decisions $\langle d_1, d_2, \ldots d_N
\rangle$. In our approach, $N$ will be a fixed number for any input
$x$: we take the $N$ decisions to correspond to the sequence of
variables {\tt STEM, SPINE, $\ldots$, MOD(1), MOD(2), $\ldots$,
MOD(n)} described in section~\ref{sec-aep}.  Each $d_i$ is a member of
a set ${\cal D}_i$ which specifies the set of allowable decisions at
the $i$'th point (for example, ${\cal D}_2$ would be the set of all
possible values for {\tt SPINE}).  We assume a function
$\hbox{ADVANCE}(x, \langle d_1, d_2, \ldots, d_{i-1} \rangle)$ which
maps an input $x$ together with a prefix of decisions $d_1 \ldots
d_{i-1}$ to a subset of ${\cal D}_i$. $\hbox{ADVANCE}$ is a function
that specifies which decisions are allowable for a past history
$\langle d_1, \ldots, d_{i-1} \rangle$ and an input $x$. In our case
the $\hbox{ADVANCE}$ function implements hard constraints on AEPs (for
example, the constraint that the {\tt SUBJECT} variable must be {\tt
NULL} if no subject position exists in the {\tt SPINE}).  For any
input $x$, a {\em well-formed} decision sequence for $x$ is a sequence
$\langle d_1, \ldots, d_N \rangle$ such that for $i = 1 \ldots n$,
$d_i \in \hbox{ADVANCE}(x, \langle d_1, \ldots, d_{i-1} \rangle)$. We
define $\gen(x)$ to be the set of all decision sequences (or AEPs)
which are well-formed for $x$.

The model that we will use is a discriminatively-trained,
feature-based model. A significant advantage to feature-based models
is their flexibility: it is very easy to sensitize the model to
dependencies in the data by encoding new features.  To define a
feature-based model, we assume a function $\rep(x, \langle d_1,
\ldots, d_{i-1} \rangle, d_i) \in \reals^d$ which maps a decision
$d_i$ in context $(x, \langle d_1, \ldots, d_{i-1} \rangle)$ to a {\em
feature vector}. We also assume a vector $\pav \in \reals^d$ of
parameter values. We define the {\em score} for any partial or
complete decision sequence $y = \langle d_1, d_2, \ldots, d_m \rangle$
paired with $x$ as:
\begin{equation}
\hbox{SCORE}(x,y) = \ip{\Rep(x,y)}{\pav}
\label{eq-score}
\end{equation}
where
$
\Rep(x,y) = 
\sum_{i=1}^m \rep(x,\langle d_1, \ldots, d_{i-1} \rangle, d_i)
$.
In particular, given the definitions above, the output structure
$F(x)$ for an input $x$ is the highest--scoring well--formed structure for $x$:
\begin{equation}
F(x) = \arg\max_{y \in \gen(x)} \hbox{SCORE}(x,y)
\label{eq-argmax}
\end{equation}
To decode with the model we use a beam-search method. The method
incrementally builds an AEP in the decision order $d_1, d_2, \ldots,
d_N$. At each point, a beam contains the top $M$ highest--scoring
partial paths for the first $m$ decisions, where $M$ is taken to be a
fixed number. The score for any partial path is defined in
Eq.~\ref{eq-score}. The $\hbox{ADVANCE}$ function is used to specify
the set of possible decisions that can extend any given path in the
beam.

To train the model, we use the averaged perceptron algorithm described
by \perscite{col:02}.  This combination of the perceptron
algorithm with beam-search is similar to that described by \perscite{colroa:04}.\footnote{Future work may consider
alternative algorithms, such as those described by \perscite{daumar:05}.} The perceptron algorithm is a convenient
choice because it converges quickly --- usually taking only a few
iterations over the training set \parcite{col:02,colroa:04}.

\subsection{The Features of the Model}
\label{sec-feats}

The model's features allow it to capture dependencies between the AEP
and the German clause, as well as dependencies between different
parts of the AEP itself. The features included in $\rep$ can
consist of any function of the decision history $\langle d_1, \ldots,
d_{i-1} \rangle$, the current decision $d_i$, or the German clause. In
defining features over AEP/clause pairs, we make use of some basic
functions which look at the German clause and the AEP (see
Tables~\ref{GERfunc} and \ref{AEPfunc}). We use various combinations
of these basic functions in the prediction of each decision $d_i$, as
described below.

\begin{table}[!h]
\begin{center}
\begin{small}
\begin{tabular}{|c|l|}
\hline
1 & main verb \\
\hline
2 & any verb in the clause \\
\hline
3 & all verbs, in sequence \\
\hline
4 & spine \\
\hline
5 & tree \\
\hline
6 & preterminal label  of left-most child of subject \\
\hline
7 & terminal label of left-most child of subject \\
\hline
8 & suffix of terminal label of right-most child of subject \\
\hline
9 & preterminal label  of left-most child of object \\
\hline
10 & terminal label of left-most child of object \\
\hline
11 & suffix of terminal label of right-most child of object \\
\hline
12 & preterminal label of the negation word {\em nicht} ({\em not}) \\
\hline
13 & is either of the strings {\em es gibt} ({\em there is/are})\\
& or {\em es gab} ({\em there was/were}) present? \\
\hline
14 & complementizers and wh-words \\
\hline
15 & labels of all wh-nonterminals \\
\hline
16 & terminal labels of all wh-words \\
\hline
17 & preterminal label of a verb in first position \\
\hline
18 & terminal label of a verb in first position \\
\hline
19 & terminal labels of all words in any relative pronoun\\
&  under a PP \\
\hline
20 & are all of the verbs at the end? \\
\hline
21 & nonterminal label of the root of the tree \\
\hline
22 & terminal labels of all words constituting the subject \\
\hline
23 & terminal labels of all words constituting the object \\
\hline
24 & the leaves dominated by each node in the tree \\
\hline
25 & each node in the context of a CFG rule \\
\hline
26 & each node in the context of the RHS of a CFG rule \\
\hline
27 & each node with its left and right sibling \\
\hline
28 & the number of leaves dominated by each node \\
&in the tree \\
\hline
\end{tabular}
\end{small}
\end{center}
\caption{Functions of the German clause used for making features in
the AEP prediction model.}
\label{GERfunc}
\end{table}

\begin{table}[!h]
\begin{center}
\begin{small}
\begin{tabular}{|c|l|}
\hline
1 & does the {\tt SPINE} have a subject? \\
\hline
2 & does the {\tt SPINE} have an object? \\
\hline
3 & does the {\tt SPINE} have any wh-words? \\
\hline
4 & the labels of any complementizer nonterminals \\
& in the {\tt SPINE} \\
\hline
5 & the labels of any wh-nonterminals in the {\tt SPINE} \\
\hline
6 & the nonterminal labels {\tt SQ} or {\tt SBARQ} in the {\tt SPINE} \\
\hline
7 & the nonterminal label of the root of the {\tt SPINE} \\
\hline
8 & the grammatical category of the finite verbal form\\
 &  {\tt INFL} (i.e., infinitive, 1st-, 2nd-, or 3rd-person pres,\\
& pres participle, sing past, plur past, past participle) \\
\hline
\end{tabular}
\end{small}
\end{center}
\caption{Functions of the English AEP used for making features
in the AEP prediction model.}
\label{AEPfunc}
\end{table}

\paragraph{STEM:} 
Features for the prediction of {\tt STEM} conjoin
the value of this variable with each of the functions in lines 1--13
of Table~\ref{GERfunc}.  For example, one feature is the value of {\tt
STEM} conjoined with the main verb of the German clause. In addition,
$\rep$ includes features sensitive to the rank of a
candidate stem in an externally-compiled lexicon.\footnote{The lexicon
is derived from GIZA++ and provides, for a large number of German main
verbs, a ranked list of possible English translations.}

\paragraph{SPINE:} 
Spine prediction features make use of the values of the variables {\tt
SPINE} and {\tt STEM} from the AEP, as well as functions of the spine
in lines 1--7 of Table~\ref{AEPfunc}, conjoined in various ways with
the functions in lines 4, 12, and 14--21 of Table~\ref{GERfunc}. Note
that the functions in Table~\ref{AEPfunc} allow us to look at
substructure in the spine. For instance, one of the features for {\tt
SPINE} is the label {\tt SBARQ} or {\tt SQ}, if it exists in the
candidate spine, conjoined with a verbal preterminal label if there is
a verb in the first position of the German clause. This feature
captures the fact that German yes/no questions begin with a verb in
the first position.

\paragraph{VOICE:} 
Voice features in general combine values of {\tt VOICE}, {\tt SPINE},
and {\tt STEM}, with the functions in lines 1--5, 22, and 23 of
Table~\ref{GERfunc}.

\paragraph{SUBJECT:} 
Features used for subject prediction make use of the AEP variables
{\tt VOICE} and {\tt STEM}. In addition, if the value of {\tt SUBJECT}
is an index $i$ (see section~\ref{sec-aep}), then $\rep$ looks at the
nonterminal label of the German node indexed by $i$ as well as the
surrounding context in the German clausal tree. Otherwise, $\rep$
looks at the value of {\tt SUBJECT}. These basic features are combined
with the functions in lines 1, 3, and 24--27 of Table~\ref{GERfunc}.

\paragraph{OBJECT:} 
We make similar features to those for the prediction of {\tt
SUBJECT}. In addition, $\rep$ can look at the value predicted for
{\tt SUBJECT}.

\paragraph{WH:} 
Features for {\tt WH} look at the values of {\tt WH} and {\tt SPINE},
conjoined with the functions in lines 1, 15, and 19 of
Table~\ref{GERfunc}.

\paragraph{MODALS:} 
For the prediction of {\tt MODALS}, $\rep$ looks at {\tt MODALS}, {\tt
SPINE}, and {\tt STEM}, conjoined with the functions in lines 2--5 and
12 of Table~\ref{GERfunc}.

\paragraph{INFL:} 
The features for {\tt INFL} include the values of {\tt INFL}, {\tt
MODALS}, and {\tt SUBJECT}, and {\tt VOICE}, and the function in line
8 of Table~\ref{AEPfunc}.

\paragraph{MOD(i):} 
For the {\tt MOD(i)} variables, $\rep$ looks at the value of {\tt
MODALS}, {\tt SPINE} and the current {\tt MOD(i)}, as well as the
nonterminal label of the root node of the German modifier being
placed, and the functions in lines 24 and 28 of Table~\ref{GERfunc}.

\subsection{Experiments with the AEP Model}
We implemented an end-to-end system for translation from German to
English using our AEP prediction model as a component. The Europarl
corpus \parcite{koe:05} constituted our training data. This corpus
contains over 750,000 training sentences; we extracted over 441,000
training examples for the AEP model from this corpus (see
\parcite{cow:06} for details on the extraction of these training
examples). We reserved 35,000 of these training examples as
development data for the model. We used a set of features derived from
the those described in section~\ref{sec-feats}. This set was optimized
using the development data through experimentation with several
different feature subsets.

Modifiers within German clauses were translated using the phrase-based
model of \perscite{koe:03}. We first generated $n$-best
lists for each modifier. We then built a reranking model to choose
between the elements in the $n$-best lists. The reranker was trained
using around 800 labeled examples from a development set.

The test data for the experiments consisted of 2,000 sentences, and
was the same test set as that used by \perscite{col:05}. We use the model of \perscite{koe:03} as a baseline for our experiments. The
AEP-driven model was used to translate all test set sentences where
all clauses within the German parse tree contained at least one verb
and there was no embedding of clauses---there were 1,335 sentences
which met these criteria. The remaining 665 sentences were translated
with the baseline system. This set of 2,000 translations had a BLEU
score \parcite{pap:02} of 23.96. The baseline system alone achieved a
BLEU score of 25.26 on the same set of 2,000 test sentences. We also
obtained judgments from two human annotators on 100 randomly-drawn
sentences on which the baseline and AEP-based outputs differed.  For
each example the annotator viewed the reference translation, together
with the two systems' translations presented in a random order.
Annotator 1 judged 62 translations to be equal in quality, 16
translations to be better under the AEP system, and 22 to be better
for the baseline system. Annotator 2 judged 37 translations to be
equal in quality, 32 to be better under the baseline, and 31 to be
better under the AEP-based system.

\section{A Syntax and Factor Based Model for SMT}
\label{future}
In the preceding section, we presented a model that predicts detailed
target-language syntactic structures, which include constraints on the
alignments between source and target parse trees. In this work, we
intend to implement a model that integrates our syntax-based system
and the factor-based system Moses. The integration involves using the
syntax-based system to predict the syntactic roles of constituents in
the source-language input, and reorder them before they are translated
using Moses. In addition, the syntax-based system would be used to
translate certain parts of the input and ensure that they appear in
the target language output. We would like to test this integrated
model with German-to-English translation, as well as
Spanish-to-English and English-to-Spanish translation. The work with
Spanish and English will form a natural continuation of the work we
performed translating from English to Spanish this summer at the
workshop. Although the primary focus of this work will be on the
integration with Moses, we see the need for improvement of our AEP
model. We hope such improvements will contribute to better quality
translations produced by the integrated system. Finally, we envision
implementation of a few alternative approaches to end-to-end
translation using the AEP model; we expect to use these alternatives
as points of comparison with the integrated approach. The next few
sections describe our proposed integration with Moses, some additional
motivations for investigating Spanish-English translation, the
AEP-prediction improvements that we anticipate carrying out, and the
alternative end-to-end translation systems.

\subsection{Integration with a Factor-Based System}
The end-to-end translation framework we have developed in previous
work uses a phrase-based system to produce $n$-best lists of modifier
translations, which are then reranked and placed into the final
translation. By selecting modifier translations independently, we are
failing to make use of valuable contextual information that could be
used to form better translations.  Rather than produce modifier
translations in isolation, we can use the syntax-based system to
produce modified MT input to the phrase-based
system. Figure~\ref{modifiedinput} illustrates how the input to the MT
system is rearranged by the syntax-based AEP model. Note that in step
two of the figure, some of the input has been translated to English
(the verb sequence {\em would like to thank}), while some if it has
merely been reordered. This allows the phrase-based system to decode
the entire AEP at once.

\begin{figure}
\begin{center}
\includegraphics[scale=1.2]{brooke-modifiedinput2}
\end{center}
\vspace{-0.5cm}
\caption{The input to the MT system --- {\em f\"{u}r seinen bericht
m\"{o}chte ich dem berichterstatter danken} --- is rearranged by the
syntax-based system to produced modified input to the phrase-based
system.}
\label{modifiedinput}
\end{figure}

An approach similar to this one has been investigated in previous work
using hand-written reordering rules, which improved translation
quality when compared with a phrase-based baseline system
\parcite{col:05}. Our current work differs from the previous work in
several significant ways:

\begin{itemize}
\item our work is carried out entirely within a statistical
framework, whereas the earlier work used hand-coded deterministic
rules for reordering;
\item our work attempts to identify the roles of target-language
output phrases and account for them in the source-language input,
whereas the previous work attempted only to reorder the input; the
prediction of grammatical functions such as {\em subject} and {\em
object} can be used as additional input to the phrase-based system
(see below);
\item our work explicitly tries to account for the existence and
translation of certain sentence elements such as complementizers,
wh-words, and main verbs;
\end{itemize}

In addition to the simple reordering of input suggested in
Figure~\ref{modifiedinput}, we envision several extensions. We might,
for instance, try training language models specific to the syntactic
roles predicted by the AEP model (e.g., subject, object, verbal
modifier). These language models could be incorporated into the
factor-based framework as additional features in the model. The use of
such language models would be motivated by the desire to have the
model learn something about the structure of a ``subject'', for
instance (e.g., that a subject should probably look like a noun
phrase).

This particular line of investigation raises many interesting research
questions related to the reordering of top-level phrases (i.e.,
modifiers):

\begin{itemize}
\item Does it help to disallow reordering of the top-level phrases in
the modified input to the phrase-based system (i.e., implement a hard
constraint on reordering)?  Or, is it better to implement a soft
constraint on reordering (for example by penalizing the reordering of
modifiers)?  Or, is it better not to impose any constraints on
reordering at all?
\item How much language engineering is necessary to extract a
reasonable subset of possible permutations of top-level phrases in the
input?  How well can the phrase-based decoder do by simply taking into
account all possible reorderings while decoding? (Note that if
arbitrary reorderings of words in the sentence are allowed, the
decoding problem is NP-complete \parcite{kni:99}.) Do we really need to
use a full parse, or can we devise a model that uses only syntactic
chunking (partial parsing) or semantic role labeling?
\item Can we simplify the role of the first (preprocessing) step,
perhaps by (1) learning a mapping from source-sentence elements to
target-sentence roles (subject, object, modifier, verb,
complementizer), and then (2) learning an ordering on those elements?
Note that this approach implies that no part of the input to the
phrase-based system would be translated by the syntax-based system.
\end{itemize}

\subsection{Other Language Pairs: Spanish/English}
We would like to test the integrated syntax and factor based system
with language pairs other than German/English, and for translation
into a language besides English.  One language pair that we are
interested in working with is Spanish/English. Spanish is interesting
for a number of reasons \parcite{zag:02}:

\begin{itemize}
\item it has a fairly rich morphology, with subjects and verbs
agreeing in number and person, and the nouns, determiners, and
adjectives in a noun phrase agreeing in number and gender;
\item constituent order is not fixed in declarative sentences
(constituents may appear as S-V-O, V-O-S, or V-S-O);
\item if understood from context, the subject does not have to appear
in a sentence;
\item the use of the subjunctive mood is quite prevalent and may be
triggered by a phrase that appears far away from the inflected verb;
\item the passive voice is used in many cases where active voice would
be the natural choice in English;
\item Spanish uses two forms of past tense (preterite and imperfect)
where English uses only one (simple);
\item Spanish has two forms of the verb {\em to be};
\item Spanish uses double clitics (that is, two clitics with the same
referent), and there are two possible positions when placing clitics
in sentences where a verb appears in the progressive or infinitive
form.
\end{itemize} 

From a research perspective, one of the benefits of our approach is
that we can leverage the relatively recent advances in parsing
languages other than English (e.g.,
\parcite{chibik:02,arukel:04,col:99b,cowcol:05}). We have developed a
statistical parser for Spanish \parcite{cowcol:05} that we intend to use
for this project. The parser makes use of morphological information
and reranking techniques to achieve, on test data, an F1 score of
85.1\% in the recovery of labeled constituents.  The parser is
currently trained on only 2800 sentences; this number will increase by
a factor of 10 with the release of new data at the end of 2006.

\subsection{Improved AEP Prediction}
Improvements in the accuracy with which the AEP model predicts AEPs
will almost certainly lead to improved translation quality, and can
only reduce the amount of work that the factor-based system has to
do. We have analyzed several random samples of output from our current
system in an attempt to characterize its current
performance. Table~\ref{errors} shows examples of some of the errors
we have observed:

\begin{enumerate}
\item {\bf subject/verb agreement}: In English, the subject and verb
must agree in number. In the example, the verb {\em to be} is
inflected for plurality, while the subject is singular.
\item {\bf subject choice}: The AEP model predicts there is no
subject, or mispredicts the alignment of the subject. In the example,
the second clause of the sentence ({\em while believe on the same side
of the political spectrum}) is missing a subject.
\item {\bf object choice}: The AEP model predicts there is no object,
or (more commonly) mispredicts the alignment of the object. In the
example, the true object --- {\em position} --- in the last clause
({\em to take in his second speech to this issue position}) is
incorrectly predicted as a modifier and is placed after the object.
\item {\bf number finite verbs}: The system occasionally produces more
than one finite verb per clause. In the example, the final clause
({\em we will come in future this is often}) contains two finite
verbs, {\em come} and {\em is}. The reason for this is usually that
the phrase-based system introduces a new finite verb in translating of
one of the modifiers.
\item {\bf preposition choice}: Either a preposition is missing, or
the choice of preposition is incorrect. In the example, the
preposition {\em at} has been selected; a more appropriate choice
would have been {\em on}.
\end{enumerate}

\begin{table}
\caption{Examples of some common errors in the output of our syntax-based system.}
\begin{center}
\begin{tabular}{p{.8in}|p{1.85in}p{1.85in}}
{\bf Error Type} & {\bf System Output} & {\bf Reference Translation}\\
\hline subject/verb agreement & the council are denied any power of legislating . & the council is denied any power of legislating .\\
\hline subject choice & mr blair sees the precondition for more liberalisation while believe on the same side of the political spectrum , this is the prerequisite for the development of a social europe & mr blair sees this as the condition for greater liberalisation , while others , on the same side of the political chessboard , believe that it is the condition for the advent of social europe \\
\hline object choice & i hope very that the prime minister sets it positive apart and would ask him if it does to take in his second speech to this issue position & i would like to hope that the prime minister will address it positively and i should like , if he can , for him to take a position on this issue in his second speech . \\
\hline number finite verbs & this annex is and i know we will come in future this is often & this is to be welcomed , and i know we will return to this many times in the future .\\
\hline preposition choice & i should like to comment at the thessaloniki agenda in the areas of immigration and asylum& mr president , i am going to refer to the thessaloniki agenda in relation to immigration and asylum .\\
\hline
\end{tabular}
\end{center}
\label{errors}
\end{table}

It is clear from this list that the prediction of particular parts of
the AEP could be improved. For instance, subjects and objects are
often not accurately predicted. In addition, we have routinely
observed that the choice of the main verb is often not optimal or even
correct. Based on our informal observations, it seems to be the case
that high-accuracy AEP prediction is correlated with high-accuracy
translation output. We intend to produce by hand a set of gold
standard AEPs which could be used to generate and score
translations. The difference between generating translations using the
gold-standard AEPs and generating translations using the predicted
AEPs will give us a more quantitative idea of the loss incurred by the
mispredictions.

The feature-driven approach allows a wide range of features to be
tested in attempting to improve AEP prediction accuracy. For example,
it would be relatively easy to incorporate a syntactic language model
(i.e., a prior distribution over AEP structures) induced from a large
amount of English monolingual data. Future work may also consider
alternative definitions of AEPs. For example, we might consider AEPs
that include larger chunks of phrase structure, or we might consider
AEPs that contain more detailed information about the relative
ordering of modifiers.

Alternative learning methods might improve the accuracy of the
model. For example, a large-margin optimization technique such as the
exponentiated gradient approach to structured prediction \parcite{bar:04}
might be adapted to the AEP prediction problem. We might also look
into improving how training examples are extracted, for instance, by
looking into a better method for extracting and aligning clause pairs
and modifiers. Our current method involves heuristics for determining
modifier alignment; this might be done instead by using the EM
algorithm to induce the best alignment.

\subsection{Alternative End-to-End Systems}
We foresee implementing at least two alternative translation systems
using our AEP model. One of these systems uses finite state machines
to represent alternative modifier translations; it is closer in nature
to our current modifier-reranking framework, although we have reason
to believe it will perform better than our current implmentation. The
other alternative involves a recursive application of the AEP model to
modifier translation.

\paragraph{Using finite state machines}
Rather than using the phrase-based system to produce $n$-best lists of
translations, we can use it to produce finite state machines (FSM)
representing a network of possible translations (see, e.g.,
\parcite{moh:97}). It is then easy to create an integrated AEP-FSM, in
which the conjunctions and other substrings of the translation derived
from the AEP are also represented as finite-state machines. We could
then take the intersection of the AEP-FSM with an $n$-gram language
model, for instance. Selecting modifiers using this representation
would correspond to searching the finite-state network for the most
likely path. Crucially, this search would take into account the
contextual information that is being thrown away in our current
reranking approach. It would also incorporate a language model over
the entire sentence. The current system uses a language model only
when producing modifier translation candidates with the phrase-based
system. Finally, the FSM framework facilitates the incorporation of
any additional models that can be encoded using a finite-state
representation. For instance, we might train language models for
particular types of modifiers predicted by the AEP (e.g., subject,
object, etc).

\paragraph{Recursive prediction of modifier AEPs}
\label{recursive}
According to most (if not all) syntactic theories, classes of words
other than verbs (such as nouns, adjectives, and prepositions) can
also subcategorize lexically for certain types of arguments, and can
influence their distributions \parcite{haegue:99}. Similarly, extended
projections may be formed for many types of words besides verbs. A
natural extension to the current AEP model, then, is the application
of AEP prediction to the translation of modifiers. For example, given
a German modifier aligned to the English subject, we may try to
predict a corresponding AEP, which would likely involve the extended
projection of a noun. Exactly how we would form the modifier AEPs (for
instance for prepositional phrases) would be part of this work.

This approach is compelling for a couple of reasons:

\begin{itemize}
\item it facilitates the modeling of syntactic structure conditioned
on the intended role (subject, object, etc) of the target-language modifier;
\item it offers an AEP framework that is entirely self-contained,
without reliance on a phrase-based system.
\end{itemize}

\noindent
This system is quite different from the integrated syntax and factor
based system and should therefore make a very interesting point of
comparison.

\subsection{Summary}
The goal of this research is to integrate a system that makes explicit
use of global syntactic information with one that is able to
incorporate factors in a phrase-based framework. We aim to use the
mutual strengths of each system to produce high-quality automatic
translations. We intend to test our model using German/English and
Spanish/English language pairs. In addition, we plan to implement
several improvements to the AEP prediction model, as well some
alternative end-to-end translation models that make use of the AEP
model and can act as points of comparison to the integrated syntax and
factor based model. We hope that this work will not only produce
better machine translation output, but will also help elucidate how
syntactic information can best be used for SMT.

\bibliographystyle{apalike}
\bibliography{biblio}

\printindex

\end{document}
